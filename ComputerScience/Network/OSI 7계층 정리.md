# OSI 7계층
OSI 7계층은 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것을 의미함

네트워크 간의 연결에 어려움이 많아 호환성의 결여를 막기 위한 것으로, ISO(국제 표준화 기구)에서는 OSI 참조모델을 제시

계층으로 나눈이유는 서로 상하구조를 가지기 때문이다. 즉, 1계층 동작하지않으면 2계층은 동작할수가없다.(Encapsulation and Decapsulation)

### OSI 7계층 그림

![image](https://user-images.githubusercontent.com/97019540/233357327-06d4fd21-8c82-492c-9a08-bbf1cb1dae14.png)



## 1계층 (Physical Layer)

> 물리적으로 연결된 두 대의 컴퓨터가 데이터를 주고받을 수 있게 해주는 계층

컴퓨터는 0과 1의 나열로 데이터를 정의한다. 그러면 통신하기 위해서 0과 1만 주고받을수 있으면 됩니다.


### 1계층 예제 그림
![image](https://user-images.githubusercontent.com/97019540/233559941-bff70cc4-0d2a-4733-bace-ca91488b2bfc.png)

위 그림처럼 캡슐화된 데이터가 1계층에 도달하면 해당 데이터를 아날로그신호로 인코딩하여 받는 쪽에서는 해당 아날로그신호를 컴퓨터가 알수 있게 해석(디코딩)하는 역할을 합니다. 두 컴퓨터간에 연결은 UTP,STP,광케이블 등등의 유선으로 연결되어 있을 수도있고 무선으로 연결되어 있을수도 있다.


__여러 컴퓨터를 연결하기 위해선?__

- 모든 전선으로 연결 ( 1 + ... + n-1 => n(n-1)/2)

    ![image](https://user-images.githubusercontent.com/97019540/233571535-633cdc20-de84-4527-a222-4dadf7df9936.png)

    <br>

    - 전선의 수가 너무 많아짐

- 허브를 통한 연결 (더미허브)

    ![image](https://user-images.githubusercontent.com/97019540/233574971-94e1ed3a-22b6-44f3-b414-5b400a466edd.png)

    - 전선의 수를 줄이는 데는 성공
    - 하지만 첫번째 컴퓨터에서 같은 네트워크의 네번째 컴퓨터로 데이터를 보내야 되면 해당 데이터가 모든 컴퓨터에 데이터를 주게된다. (원치 않은 브로드캐스팅 문제 , 목적지 구분이 안됨)
    - 보안 이슈
    - 첫번째 컴퓨터가 전송하고 있을때 다른 컴퓨터가 전송하게되면 이미 첫번째 컴퓨터가 전송경로 점유하고 있기때문에 충돌 위험 (반이중 방식)


### 물리계층 장비
- 리피터

    ![image](https://user-images.githubusercontent.com/97019540/233921966-5f1f9169-775c-49a1-bac1-9cb677849b8d.png)

    - 먼 거리를 통신할때 신호를 증폭시켜주는 장비
    - 리피터는 최대 4개로 제한되어 있다.
    - 망내에 잡음도 같이 증폭된다.

- 허브 (더미허브)

    ![image](https://user-images.githubusercontent.com/97019540/233574971-94e1ed3a-22b6-44f3-b414-5b400a466edd.png)

    - 리피터의 기능을 가지고 있음
    - 멀티포트를 지원
    - 네트워크에 컴퓨터가 3대 이상일경우 한 컴퓨터에서 신호를 보내면 같은 네트워크에 모든 컴퓨터들도 다 받게된다.
    - 네트워크내에 장치가 많을수록 부하가 심해진다.

- 랜카드

    ![image](https://user-images.githubusercontent.com/97019540/233925465-afb34a04-a083-4048-87e3-4055708cc871.png)

    - 비트열 (0과 1)을 전기 신호로 변환
    - MAC주소를 가지고 있다.

### 물리계층 역할 정리

- 데이터를 아날로그 신호로 바꾸어 전선으로 흘려 보내줌 (Encoding)

- 아날로그 신호가 들어오면 데이터로 해석함 (Decoding)

- 전송매체는 유선으로는 우리가 잘아는 케이블중 랜선(UTP케이블),광케이블 등이 있고, 광케이블 등등 무선으로는 전자기파가 있다.

- 미디어 타입, 커넥터 타입, 신호표현 방법, 즉 시그널링, 속도 등을 정의


## 2계층 (DataLink Layer)

> 같은 네트워크상에 서로 다른 두대의 컴퓨터가 연결할 수 있게 해주는 계층

1계층에서 허브의 멀티포트를 통해 여러개의 장치가 연결되었는데 한 컴퓨터에서 신호를 보내면 모든 컴퓨터에 신호가 전송되었다.
그러면 수신하는 컴퓨터에 목적지에 데이터를 전송하기 위해서 어떻게 해야될까?

2계층에서는 LAN카드(NIC)에 MAC주소를 이용하여 통신을 한다.

1계층에서 설명했던대로 각각 통신장비에 LAN카드에는 MAC주소를 가지고있다. (MAC주소는 변경이 가능하다.)



### 2계층 예제 그림

![image](https://user-images.githubusercontent.com/97019540/234534358-154ce856-a22f-4734-8482-2e95418af40e.png)


위의 그림대로 2계층에서는 같은 네트워크에 서로 다른 두대의 컴퓨터가 통신을 할수 있게 Mac주소를 이용하여 통신한다.

포트1번에 연결된 컴퓨터가 포트4번에 연견된 컴퓨터에 0011이라는 데이터가 담긴 프레임을 보낸다.

하지만 스위치는 처음에 프레임을 보낼때 출발지 MAC주소가 AA:BB:CC:DD:EE:F1이니까 포트1번에 AA:BB:CC:DD:EE:F1인것만 알고`(Learning)` 목적지주소인 ~:::::F4이 어떤 포트인지는 모른다고 가정할 때
`Flooding`이 동작하는데 이는 Mac 주소 테이블에 포트번호와 맥주소가 없을때 브로드캐스트되서 스위치에 연결된 모든 컴퓨터에 프레임을 보내고 도착지 맥주소가 자기 맥주소와 비교하여 해당 프레임을 무시한다. 즉, 컴퓨터2와 컴퓨터3은 프레임을 받게되지만 무시하게 된다.

위 그림처럼 포트4번이 스위치 MAC 주소 테이블에 저장되어 있을때에는 `Forwarding` 하게되고 도착지 맥주소가 테이블에 저장되어 있기 때문에 포트4번으로만 프레임을 전송(`Filtering`)하게 된다.

또 Mac 주소 테이블에는 `Aging` 기능도 있는데 이는 맥주소를 `Learning` 했을때 저장해놓는 시간을 정합니다. (보통 300초를 저장한다함)
즉, 스위치는 Mac주소를 영구적으로 저장하지는 않는다.


### Frmae이란?

__EthernetII 그림__

![image](https://user-images.githubusercontent.com/97019540/234534538-f1f5d2d2-6705-4633-9b0c-7fdec2b568f0.png)

위 그림처럼 2계층의 데이터단위를 Frame이라고 한다.
2계층 프로토콜로는 IEEE 802.3 , DIX 2.0 , PPP, HDLC 등등이 있는데 LAN 통신 표준은 IEEE 802.3이지만 DIX 2.0(Ethernet II)이 주로 사용되고 있다. WAN 통신 시에는 PPP가 주로 사용된다고 한다.

근거리 네트워크 통신을 LAN이라 하고 원거리 네트워크 통신을 WAN이라고 한다. 나중에 라우터와 라우터사이에 먼 거리를 통신할때 2계층에서 WAN 통신 프로토콜이 사용된다고 볼수있다.

__Ethernet Frame 구조__
- Mac Frame
    - Header
        - Mac dst : 목적지 Mac 주소 
        - Mac src : 출발지 Mac 주소
            > Mac dst와 src는 3byte씩 구분되어있음 (총 6Byte)
            > 앞의 3Byte는 OUI(제조사번호) 뒤 3Byte는 (해당 업체 랜카드 식별변호)<br>
            > OUI 24bit중에 제일 오른쪽 1bit는 Multicast와 Unicast를 표시하기위한 비트인데 `0일시 unicast 1일시 multicast를 의미`한다 (Least Significant Bit 라고함)
            > 목적지 주소 6Byte(=48bit)가 전부 1일경우 Broadcast됨

        - EtherType / Length : 상위계층의 프로토콜 타입을 표시 / LLC(Logical Link Controller) Frame 길이
            - 0000~05dc(10진수로 0~1500)이면 IEEE 802.3 프레임 포맷의 DATA영역의 길이이다
            - 0600부터(DIX2.0 프레임 포맷)는 상위 프로토콜 타입을 의미한다. (`EtherType 참고링크 : https://en.wikipedia.org/wiki/EtherType#cite_note-ethtypes-7`)

    - Data
        - 프레임의 최소크기는 64byte이고 Header의 크기는 14 (목적지주소 6,출발지 6 , type length 2)
            오류제어 필드 4Byte (FCS 4)
        - 그러면 Data영역의 크기는 64-18 = 48Byte가 되고 또 data가 48Byte보다 작을시에 Pad가 추가된다
        - Pad는 0으로 채워진값 (padding) 48Byte보다작을 시 맞추기위해 사용 

    - Trailer (CRC (Cyclic Redundancy Check = FCS))
        - Preamble과 SFD는 제외한다 (Mac Frame이 아니기때문에)
        - DA + SA + Length + DATA 영역을 계산
        - MAC Controller는 Frame을 송신하면서 동시에 CRC를 계산한 후 DATA뒤에 추가
        - 수신쪽 MAC Controller도 수신하면서 동시에 CRC 계산한 후 수신된 CRC가 일치하는지 검사하고 틀리다면 폐기

__Preamble과 SFD??__
 1. Preamble
- 송신측 과 수신측간의 송/수신 속도를 일치시키기 위한 `비트 동기 (Bit Synchronization)`
- 10101010이 7회 연속 반복되는 56bit로 구성 
    > 실제 Ethernet Frame이 시작 되기전에 Preamble을 전송해 clock동기를 맞춥니다.
 2. SFD (Start Frame Delimiter)
- Frame Bit열에서 Byte단위를 식별하는 Byte동기
- 정상적인 프레임의 내용이 시작된다는 사실을 알려주는 Frame동기
- 10101011의 8Bit로 구성
- Preamble 과 SFD는 모두 MAC Controller Chip에서 생성 된다.

> 🎇 EthernetII (DIX 2.0)은 SFD는 없고 Preamble이 64bit(8Byte)로 되어있다!<br>
> ✨ Preamble과 SFD는 Physical Layer(물리계층) Header 이다.


### 데이터링크 장비

- `브릿지` :  콜리전 도메인을 나누어주는 역할
    - 소프트웨어 기반으로 동작함
    - MAC 주소 기반으로 작동
    - 필터링을 통해 Collision Domain (충돌 영역)을 줄여준다.
    - 브릿지도 전송거리를 연장시켜주는데 전기적 신호만을 증폭시키는게 아니라 Frame을 재생성하여 전송해준다.

- `L2 스위치` : 브리지의 기능 + 전이중 통신방식, 즉, 충돌이 일어나지 않는 구조의 통신장비
    - 전이중 통신방식이란 두 대의 단말기가 데이터를 송수신하기 위해 각각 독립된 회선을 사용하는 통신 방식 (포트당 하나의 Collision Domain)
    - 하드웨어 기반으로 동작
    - Mac Address Table에 목적지 주소만 보고 Frame전송
    - 각각의 포트마다 통신속도 설정 가능

### L2 스위치 주요기능
- Mac Address Table : Port번호와 Mac Address를 매핑한 테이블 
- Learnig : 위 그림예제에서 설명했듯이 스위치는 해당 포트에서 프레임이 넘어오면 해당 포트에 연결된 Mac주소를 학습한다
- Flooding : 전송된 프레임에 도착지 Mac주소가 Mac Address Table에 없을 경우 전송받은 포트를 제외한 나머지 포트에 프레임을 전송하는것
- Forwarding : 스위치에 전달받은 도착지 Mac주소가 Mac Address Table에 있을 경우 해당 Mac주소와 일치하는 포트로 프레임을 전달하는것
- Filtering : Forwarding(전송될 포트를 제외한 나머지 포트) 과 Flooding(스위치에 프레임을 보낸 포트) 시 다른포트에 프레임이 가는것을 차단시켜주는것
- Aging : Learnig시에 매핑된 Prot번호와 Mac Address를 영구적으로 저장하지않고 제한시간을 둠 (기본 300초)

> ARP는 3계층에서 다루겠습니다!!

### 데이터링크 계층 역할 정리
<br>

- 프레이밍: 데이터 링크 계층에선 `네트워크 계층에서 받아온 데이터그램`을 `프레임 단위`로 만들고 `헤더와 트레일러를 추가`
- 흐름제어: 송수신자 간 데이터를 처리하는 속도 차이를 해결하기 위한 제어도 담당
- 오류제어: 프레임 전송 시 발생한 오류를 복원하거나 재전송
- 접근제어: 매체 상 통신 장치가 여러 개 존재할 때, 데이터 전송 여부 결정

> 데이터링크 계층 기술도 랜카드에 구현되어 있다.
> 랜카드에서 송신할 데이터를 받아 이더넷헤더와 Trailer를 붙여 MAC Frame을 만들고 동기화 비트 Preamble헤더를 추가하여 전기신호로 만들어 전송한다.



## 3계층 (Network Layer)

2계층은 같은 네트워크내에 직접 연결된 기기의 통신을 다뤗다면 3계층은 서로 다른 네트워크에 있는 기기의 통신을 도와준다.

Internet Protocol(IP)를 이용하여 통신하고 목적지의 네트워크 대역대의 라우터(종단 노드)를 찾아주는 역할을 한다.

3계층의 데이터 단위는 Packet이라 한다.

### 3계층 헤더 구조(IP Header)

![image](https://github.com/9ony/9ony/assets/97019540/e3362881-a88c-4591-934c-b03fb18157d8)
 
- Version (4 bits): IP 헤더의 버전  IPv4는 4 , IPv6는 6 <br>

- Header Length (4 bits): IP 헤더의 길이를 32비트 단위로 표시 헤더의 시작으로부터 실제 데이터의 시작까지의 길이 <br>

- Type of Service (8 bits): 서비스의 우선순위 또는 서비스의 특성을 나타냄. 주로 트래픽의 우선순위, QoS (Quality of Service) 설정 등을 지정하는데 사용<br>

- Total Length (16 bits): IP 패킷의 전체 길이를 바이트 단위로 나타냄 ( 헤더 길이 + 데이터 길이 ) <br>

- Identification (16 bits): IP 패킷의 유일성을 식별하기 위한 값 패킷 조각화(fragmentation) 및 재조립(reassembly) 과정에서 사용 <br>

- Flags (3 bits): 패킷 조각화와 관련된 플래그를 나타냅니다. 주로 패킷 조각화에 대한 제어 정보가 담겨져 있음<br>

- Fragment Offset (13 bits): 패킷 조각화에서 조각의 위치 (원본 패킷에서의 조각의 상대적인 위치를 나타냄)<br>

- Time to Live (TTL) (8 bits): 패킷의 수명을 나타내며, 네트워크를 통과할 때마다 값을 1씩 감소시킵니다. TTL이 0이 되면 패킷은 폐기됨<br>

- Protocol (8 bits): IP 패킷이 상위 계층 프로토콜 (예: TCP, UDP) 중 어떤 프로토콜을 사용하는지 나타냄 <br>

- Source Address (32 bits): 송신자의 IP 주소 <br>

- Destination Address (32 bits): 수신자의 IP 주소 <br>

- Options (변동적인 길이): 추가적인 IP 옵션 정보가 필요한 경우 사용됩니다. 이 영역은 선택 사항임 <br>

### 3계층 예제 그림

![image](https://user-images.githubusercontent.com/97019540/235298886-bbb49af2-5093-4f84-8301-146737c4d1bd.png)

> 게이트웨이 주소는 보통 관례적으로 호스트ID의 마지막번호를 쓴다고한다!!<br>
(저는 임시로 1로 줬습니다 원래는 254 host id 범위가 1~254기 때문에)

__출발지 PC에서 목적지 PC까지 통신하는 과정__

1. 출발지 PC는 목적지의 IP만 알고 MAC주소는 알지 못한다.
출발지와 목적지가 네트워크 대역이 다르기 때문에 출발지 PC는 GateWay IP주소(라우터)로 패킷을 보내게 되는데 라우터의 맥주소를 모른다고 가정하면 ARP 요청(BroadCast)을한다.

  > 이때 스위치는 2계층이므로 이더넷프레임까지만 역캡슐화를하고 브로드캐스트인걸 확인하고 전송받은 포트빼고 나머지 포트에 프레임을 전송함!!

  라우터는 ARP요청에 응답받아 Mac주소를 알려주고(`ARP Reply`) 출발지 PC는 패킷을 라우터에 전달한다. (`ARP Cache Table`에 해당 정보를 저장함)

<br>

2. 라우터 1은 해당 목적지IP를 `라우팅 테이블`을 조회하여 자신의 인터페이스중 어느 인터페이스로 전송해야 할지 결정하게된다.
    > ( 결정된 다음 인터페이스를 `Next Hop`이라 한다. )
    이를 라우팅이라하고 목적지까지 패킷을 전송하는 최적경로를 계산한다.
    >위와 마찬가지로 해당 인터페이스에 대응되는 MAC 주소를 알아내기 위해 ARP 프로토콜을 사용하고 패킷을 전송해가면서 다음 Next Hop에서 위 과정을 반복하여 라우터3까지 도착하게 된다.

<br>

3. 라우터 3은 목적지 IP가 자신의 네트워크 대역대이면, 해당 IP 주소를 가진 호스트가 자신의 네트워크 상에 있는 것이므로 패킷을 해당 호스트로 전송합니다. 이때, 라우터 C는 목적지 MAC 주소를 알기 위해 ARP 프로토콜을 사용하여 ARP 요청을 보내고, 해당 호스트로부터 ARP 응답을 받고 목적지 MAC 주소를 확인받아서 패킷 전송한다.

### 라우팅 테이블 예시

![image](https://user-images.githubusercontent.com/97019540/235845253-38955570-466e-461b-832d-aa98866fab1c.png)

> 편의상 CIDR 표기법 사용 `route print 기준`으로는 해당 네트워크주소와 서브넷마스크가 따로 적혀있음

__윈도우에서 rount print한 그림__

![image](https://user-images.githubusercontent.com/97019540/235847016-b2efc355-e036-4ba3-868d-36dd49b4e0af.png)


- 목적지 네트워크 주소 : 해당 네트워크로 가야되는 주소를 표시 (목적지 IP 와 NetMask를 AND연산한 결과값)
- GateWay : 해당 네트워크 주소로 통신을 위한 게이트웨이를 표시
- NIC : 다음 홉으로 가기위한 인터페이스를 표시 (리눅스는 해당 인터페이스명이 표시된다.)
- 홉 거리 : 해당 네트워크까지 홉의 거리를 표시 (RIP 프로토콜의 hop count)
- 메트릭 : 해당 네트워크까지 우선 순위를 매길 수 있게끔 숫자로 환산하는 값 (최적 경로 선택 기준 값)


### ARP/RARP
- ARP : IP주소를 MAC주소로 Binding,Matching 시켜주는 프로토콜    
    - ip만 알고 mac주소를 모를때 사용되는 프로토콜이다.
    - 요청을 할땐 BroadCast
    - 응답받을땐 UniCast (요청을 받은쪽에서 보낸쪽에 응답하기때문)
- RARP : ARP와 반대되는 프로토콜 Reverse ARP임. 즉, Mac만알고 ip를 모를때 사용

- GARP : 같은 네트워크내 장치들의 오류제어 목적인 프로토콜
    - 같은 네트워크 망 안에서 IP 주소 충돌을 방지하기 위해서 이미 사용되고 있는지 GARP를 통해 확인할 수 있다.
        만약 GARP에 대한 응답이 오면 'IP 주소 충돌'과 관련된 에러메시지를 사용자에게 알려준다.
    - 같은 네트워크 망 내부에 존재하는 단말들의 ARP 테이블을 갱신하는 것이다.

    - 가상 MAC을 사용하는 클러스터링, VRRP, HSRP와 같은 FHRP (Fisrt Hop Redundancy)에도 GARP가 사용된다.
        네트워크에 있는 스위치 장비의 MAC 테이블 갱신이 목적이다.

- ARP Cache Table : ARP요청 시 IP와 MAC주소가 매핑된 정보를 저장하는 테이블이다.
    - 해당 IP에 패킷은 보낼때 해당 테이블을 조회하여 매핑된 정보가 있으면 사용한다.
    - MAC Address Table과 같이 `Aging Time`이 존재함.

> ARP 헤더는 이더넷프레임과 패킷사이에 위치합니다!! 2계층 프로토콜인지 3계층 프로토콜인지 저도 헷갈려서 일단 IP를 사용하기 때문에 3계층에서 정리했습니다만, 2계층 프로토콜이라는 의견도있어서 헷갈리네요 😂

### 3계층 장비

- `라우터` : 이더넷의 범위에 있는 독립적인 네트워크들을 네트워크 계층의 기능으로 분리하며 중계하는 기능을 가진 장비
    - Routing Table이 존재함 (이웃하는 라우터와 라우팅정보를 지속적으로 제공)
    - 라우터끼리 상호연결된 복잡한 망에서 경로의 배정 및 제어를 자동적으로 수행 (Routing)
    - 최적경로중 하나의 링크가 고장나면 우회경로도 제공 
    - 허용되지 않은 트래픽을 차단하거나 거부함으로써 네트워크 보안을 유지 (패킷 필터링)

- `L3 스위치` : 랜 사이에 있는 데이터 전송을 처리하고 VLAN기능 제공
    - 스위치와 라우터의 기능을 결합
    - 라우터보다 더 빠르고 성능이 좋음


### 라우팅 프로토콜 종류

- 내부라우팅(IGP): 같은 AS내부(같은 네트워크안의 게이트웨이)의 라우팅 정보를 교환하는 프로토콜
    > RIP, IGRP, EIGRP, OSPF

- 외부라우팅(EGP): 다른 AS간(서로 다른 게이트웨이 간)의 라우팅 정보를 교환하는 프로토콜
    > BGP 

### 네트워크 계층 역할 정리

패킷 분할 및 전송: 네트워크 계층에서는 상위 계층인 전송 계층에서 전송된 데이터를 일정한 크기의 패킷으로 분할하고 이 패킷은 네트워크를 통해 전송함

논리적 주소 지정:네트워크 계층에서는 각 호스트와 라우터에는 고유한 IP 주소가 할당됨
출발지와 목적지의 논리주소를 헤더에 추가하고 논리적 주소인 IP 주소를 사용하여 통신한다.

라우팅: 패킷이 출발지에서 목적지로 전송될 때, 여러 개의 라우터를 거치면서 전달되는데 네트워크 계층에서는 라우팅 프로토콜을 사용하여 최적의 경로를 선택하고 패킷을 전달한다.

오류 제어: 패킷이 전송 중에 손상되거나 분실을 방지하는 기능
- 패킷이 폐기되거나 헤더 상에 알 수 없는 정보가 있을 때, 오류제어를 할 수 있는 보조 프로토콜인 ICMP를 제공
- 전체 데이터그램이 아닌 헤더의 훼손을 방지를 위한 CheckSum필드 추가
- CheckSum은 Hop to Hop 사이, Host to Host 간의 데이터 전송 시 데이터그램의 헤더가 변경되거나 훼손되는 것을 방지

흐름 제어: 네트워크 계층에서는 패킷의 전송 속도를 조절하여 네트워크의 혼잡을 방지하고 효율적인 데이터 전송을 유지한다.
    - 송신자가 수신자가 허용할 수 있는 만큼의 데이터만 보내도록 조절
    - 이를 위해서 수신자가 송신자에게 알리는 피드백 메커니즘 필요함

> 중요한 오류제어와 흐름제어는 상위계층에서 구현되어 있다. `네트워크 계층에서는 라우팅 기능이 핵심`이라 할수 있다.
> 네트워크 계층은 운영체제 커널에 소프트웨어적으로 구현되어 있음.


## 4계층 (Transport Layer)

4계층은 데이터가 어떤 프로세스(응용 프로그램)에 데이터를 송신할지 식별하기위한 역할이다.
이를 위해 Port Address (포트번호)인 논리적인 주소가 사용된다.
그리고 신뢰성있는 프로세스간의 통신을 담당하는 계층이다.
4계층은 Segment(세그먼트)라는 데이터 단위를 사용한다.

### 전송계층 예제 그림

![image](https://user-images.githubusercontent.com/97019540/236669390-3b003617-91d0-463d-85f6-f718611158b7.png)

그림을 보면 다른 네트워크상에 클라이언트와 서버가 네트워크 레이어를 통해 연결되어있고 클라이언트에서 크롬과 엣지를 켰는데 서로 다른 포트번호가 부여되어 있다.
그리고 클라이언트의 각각의 프로세스인 크롬은 채팅기능의 프로세스와 통신하고 엣지는 주문기능의 프로세스와 리뷰기능의 프로세스와 통신하고 있다.
이때 서버도 각각의 기능을 가진 프로세스마다 포트번호가 부여되어있다.
이렇게 포트번호를 통해 어떤 프로세스인지 식별할 수 있다.

__만약 포트번호가 없다면 어떻게 될까?__
클라이언트와 서버는 해당 서로의 위치를 네트워크계층을 통해 알고는 있지만 클라이언트에서 크롬으로 서버에서 채팅기능을 이용한다고 가정하여 채팅에 필요한 패킷을 해당 프로세스로 전송했는데 프로세스중 어떤것이 채팅기능을 가진 프로세스인지는 알지 못하게된다!

즉,네트워크 계층에서 서로 다른 네트워크에 통신을 위해 라우터를 이용하여 통신을 했다면 전송계층은 프로세스끼리 통신을 하는데 이때 식별하기 위한 번호가 포트번호이다.

그리고 패킷이 전송 과정에서 아무 문제 없이 제대로 수신지 컴퓨터에 도착할 수 있도록 패킷 전송을 제어하는 역할(오류 제어)과
네트워크 혼잡도에 따라서 패킷의 전송량을 조절하는(흐름 제어) 역할을 한다.

__IP + 포트번호와 웹서버 통신__

![image](https://user-images.githubusercontent.com/97019540/236674968-1d5ece1c-7499-460f-a8ea-0eea0a9b2c24.png)

위 그림과 같이 우리가 네이버에 접속할때 보통 www.naver.com을 입력해서 들어갔을 것이다.

하지만 `www.naver.com의 도메인네임의 ip가 223.130.195.200이라는 가정`하에 주소만 입력하게 된다면 해당 ip주소의 서버에 어떤 프로세스에 갈지가 모르기 때문에 접속이 안된다.

하지만 우리는 평소에 주소를 치면 네이버 웹서버로 접속하게되는데 이유는 `80포트번호를 생략`해도 `자동으로 뒤에 :80` 포트번호가 붙는다

> 네이버를 쳐서 들어가면 `HTTP:`가 아닌 `HTTPS:`인데 기본적으로 HTTPS는 443포트로 정해져있다.<br>
> 이는 네이버서버에 80포트로 접속할시 443으로 redirect가 되기 때문이다. 


### PORT

- 관점에 따른 포트의 여러가지 해석
    - 프로세스를 식별하기 위한 번호 (앱 개발자 관점)
    - 서비스를 식별하기 위한 번호 (네트워크 개발자 관점)
    - 인터페이스를 식별하기 위한 번호 (하드웨어 개발자 관점)

- 16bit (0~65535)
    - 0번 ~ 1023번: 잘 알려진 포트 (well-known port) [참고주소](https://ko.wikipedia.org/wiki/%ED%8F%AC%ED%8A%B8_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9))
    - 1024번 ~ 49151번: 등록된 포트 (registered port)
    - 49152번 ~ 65535번: 동적 포트 (dynamic port)

    > 클라이언트에서 프로세스들은 보통 동적포트가 할당된다<br>
    > 서버의 프로세스들은 개발단계에서 고정적인 포트번호(웰논 포트,레지스터드 포트)를 사용한다

### 전송계층 프로토콜 종류

> TCP , UDP , UDP-LITE , MPTCP , SCTP , DCCP , RUDP

### TCP(연결형 통신) 프로토콜

- __🔍 특징__
    - 패킷을 순서대로 보낸다.
    - 패킷에 문제가 있을 경우에 재전송한다.
    - Control Flags로 연결,응답,종료 비트를 송수신한다.
    - 연결과 종료시에 3way-handshake , 4way-handshake 과정을 거친다.

- __TCP 구조__

    ![image](https://user-images.githubusercontent.com/97019540/236785517-aa77396f-b689-493c-8d91-82e0434b033a.png)

    - Source port (16 비트)
        
        송신 포트
    - Destination port (16 비트)
        
        수신 포트
    - Sequence number (32 비트)
        
        SYN 플래그가 (1)로 설정된 경우, 이것은 초기 시퀀스 번호가 된다. 실제 데이터의 최초 바이트 값과 그에 상응하는 ACK 번호는 이 값에 1을 더한 값이 된다.
        SYN 플래그가 (0)으로 해제된 경우, 이것은 현재 세션의 이 세그먼트 데이터의 최초 바이트 값의 누적 시퀀스 번호이다.
    - Acknowledgment number (32 비트)
        
        ACK 플래그가 설정된 경우 이 필드의 값은 수신자가 예상하는 다음 시퀀스 번호이다. 이것은 모든 선행하는 바이트들(존재할 경우)에 대한 수신에 대한 확인응답이 된다. 한쪽이 보낸 최초의 ACK는 반대쪽의 초기 시퀀스 번호 자체에 대한 확인응답이 되며, 데이터에 대한 응답은 포함되지 않는다.
    - Data offset (4 비트)
        
        32-bit 워드 단위로 나타낸 TCP 헤더 크기값이다. 헤더의 최소 크기는 5 워드이며 최대 크기는 15 워드이다. 따라서 최솟값은 20바이트, 최댓값은 60바이트가 되며, 헤더에 선택 값을 위해 최대 40 바이트가 더 추가될 수 있다. 데이터 오프셋이라는 명칭은 이것이 실제 데이터 상에서의 TCP 세그먼트의 시작 위치의 오프셋이기 때문에 붙여졌다.
    - Reserved (3 비트)
        
        미래에 사용하기 위해 남겨둔 예비 필드이며 0으로 채워져야 한다.
    - Flags (9 bits) (혹은 Control bits)
        
        9개의 1비트 플래그를 포함
        - NS : ECN-nonce 은폐 보호(RFC 3540에 의해 헤더에 추가).
        - CWR : 혼잡 윈도 축소(Congestion Window Reduced) 플래그는 송신측 호스트에 의해 설정되는 것으로, 호스트가 ECE 플래그가 포함된 TCP 세그먼트를 수신했으며 혼잡 제어 메커니즘에 의해 응답했음을 알리는 역할을 한다(RFC 3168에 의해 헤더에 추가).
        - ECE : ECN-Echo는 다음을 나타낸다.

            SYN 플래그가 (1)로 설정된 경우, TCP 상대가 명시적 혼잡 통지(Explicit Congestion Notification, ECN)가 가능함을 의미한다.
            
            SYN 플래그가 (0)으로 해제된 경우, IP 헤더 셋에 혼잡 경험(Congestion Experienced) 플래그가 설정된 패킷이 정상적인 전송 중에 수신되었다는 것을 의미한다(RFC 3168에 의해 헤더에 추가).
        - URG : Urgent pointer 필드의 값이 유효함을 나타낸다.
        - ACK : Acknowledgment 필드의 값이 유효함을 나타낸다. 클라이언트가 보낸 최초의 SYN 패킷 이후에 전송되는 모든 패킷은 이 플래그가 설정되어 있어야 한다.
        - PSH : 푸시 기능. 수신 애플리케이션에 버퍼링된 데이터를 푸시해 줄지 여부를 질의하는 역할을 한다.
        - RST : 커넥션 리셋
        - SYN : 동기화 시퀀스 번호. 양쪽이 보낸 최초의 패킷에만 이 플래그가 설정되어 있어야 한다. 다른 일부 플래그들의 의미가 이 플래그의 값에 따라 바뀌며, 일부 플래그들은 이 플래그가 설정되어 있을 때만 유효하고, 또 다른 일부 플래그들은 이 플래그가 해제되어 있을 때에만 유효하다.
        - FIN : 남은 송신측 데이터 없음
    - Window size (16 비트)

        수신 윈도의 크기. 해당 세그먼트의 송신측이 현재 수신하고자 하는 윈도 크기(기본 단위는 바이트). acknowledgment 필드의 시퀀스 번호보다 큰 값이어야 한다.
    - Checksum (16 비트)

        헤더 및 데이터의 에러 확인을 위해 사용되는 16 비트 체크섬 필드
    - Urgent pointer (16 비트)

        URG 플래그가 설정된 경우, 이 16 비트 필드는 시퀀스 번호로부터의 오프셋을 나타낸다. 이 오프셋이 마지막 긴급 데이터 바이트를 가리킨다.
    - Options (가변 0–320 비트, 32의 배수)

        이 필드의 길이는 데이터 오프셋 필드에 의해 결정된다. 이 부분은 Option-Kind (1 바이트), Option-Length (1 바이트), Option-Data (가변) 이렇게 최대 3개의 필드로 구성될 수 있다. Option-Kind 필드는 옵션의 종류를 나타내며, 세 가지 필드 중 유일하게 필수값이다. 옵션의 종류에 따라 나머지 두 개의 필드가 설정될 수 있다. Option-Length 필드는 옵션의 전체 길이를 나타내며, Option-Data 필드는 적용 가능한 경우 해당 옵션의 값을 나타낸다. 예를 들어, Option-Kind 바이트 값이 0x01인 경우 이는 패딩의 용도로만 사용되는 옵션없음(No-Op) 옵션을 의미하며, 이 때에는 뒤따라 오는 Option-Length나 Option-Data 값이 존재하지 않는다. Option-Kind 바이트 값이 0인 경우 이는 옵션종료(End Of Options) 옵션을 의미하며, 전자와 마찬가지로 뒤따라 오는 추가 옵션 필드가 없다. Option-Kind 바이트 값이 0x02인 경우 이것은 최대 세그먼트 크기(Maximum Segment Size) 옵션을 의미하며, 그 뒤에는 MSS 필드의 길이값(0x04여야 함)이 따라오게 된다. 이 길이값은 Option-Kind와 Option-Length를 포함한 주어진 옵션 필드의 전체의 길이를 나타내는 것이다. 따라서 MSS 값은 일반적으로 2 바이트로 표현되며, 해당 필드의 길이는 4 바이트(kind와 length의 2바이트를 더한 값)가 된다. 실제 예를 들어 설명하면, 0x05B4라는 값을 갖는 MSS 옵션 필드는 (0x02 0x04 0x05B4)의 형태로 TCP 옵션 섹션에 나타날 것이다.
        일부 옵션은 SYN 플래그가 설정되어 있을 때에만 송신된다. 이러한 옵션은 아래에 [SYN]으로 표시되어 있다. Option-Kind 및 기본 Option-Length는 (Option-Kind, Option-Length)으로 표시되었다.
    - Padding

        TCP 헤더 패딩은 TCP 헤더의 종료 지점과 데이터의 시작 지점을 32 비트 단위 길이에 맞추기 위해 사용된다. 패딩의 값은 0이다.[10]

    [TCP 헤더 구조 출처](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)

- __TCP 동작 흐름__

    - 3-Way handshake (연결하기 위한 초기화 동작)

        ![image](https://github.com/9ony/9ony/assets/97019540/68cccd94-fa4c-469f-bb59-3eb4d731614b)

        1) 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보낸다.<br>
        클라이언트는 SYN 패킷을 보내고 난 후 SYN/ACK 응답을 기다리는 SYN_SENT 상태, 이때 서버는 클라이언트의 SYN패킷을 기다리는 상태(LISTEN)이다.
            
        > 이때 패킷을 보낼때 위에 TCP 프로토콜에 구조를 참고해보면 Seq Num과 Ack Num이 있는데<br>
        초기에 클라이언트가 Seq num을 랜덤으로 부여(`ex) 100`)해서 보내고 Ack num을 0으로 설정해서 보내는데 <br>
        클라이언트가 해당 Seq Num가 분할된 데이터 크기의 최초의 바이트값을 의미한다.

        2) 서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN 플래그가 설정된 패킷을 전송하고 클라이언트가 다시 ACK으로 응답하기를 기다린다. 이때 서버는 SYN_RCV (RECEIVED) 상태가 된다.<br>

        > 서버는 클라이언트에서 온 Seq Num+1값을 ACK Num값 (`ex) 101`)으로 보낸다.
        그리고 서버도 Seq Num을 랜덤으로 생성(`ex) 200`)하여 클라이언트에 보내게 된다. 

        3) 클라이언트는 서버에게 SYN에 대한 응답 플래그인 ACK을 보낸 후로부터는 연결이 이루어진 상태고 서버가 ACK를 받으면 ESTABLISHED 상태가 된다.

        > 클라이언트가 서버의 Seq Num+1 값을 Ack Num에 담아서(`ex) 201`) 응답하게 되면 서로 연결이 수립되게 된다.

        위 과정처럼 3-Way handshake는 클라이언트와 서버는 서로 연결을 수립시키기 위한 동작입니다.<br>
        이 과정에서 서로 초기 Seq Num을 동기화하고 Seq Num과 Ack Num을 이용해 패킷이 손실 됬는지 여부를 확인할 수 있고 또 순서를 보장받을 수 있습니다.<br>

        🎇 추가적으로 위 그림에선 없지만 3-Way handshake 과정중에 서로 윈도우 사이즈(rwnd)의 정보도 포함시켜 보내는데 이것은 밑에 TCP 데이터 전송과정에서 다루겠습니다.

    - TCP 데이터 전송

        ![image](https://github.com/9ony/9ony/assets/97019540/6cef115b-9d87-44d6-9a4f-c0c0ae826b58)

        TCP 프로토콜 통신시 클라이언트와 서버가 데이터를 통신할때의 과정이다.<br>
        위에 3-way handshake 절차를 통해 일련번호(Seq num)과 확인응답번호(Ack Num)이 101,201로 할당 되어있다.<br>

        1 ) 클라이언트가 서버에 데이터를 5Byte전송하면 Seq = 101, Ack = 201 , Len = 5(Byte)를 보낸다

        2 ) 서버는 Seq = 201 Ack = 106 (101+5) 을 전송하여 정상적으로 수신됬음을 알린다.

        3 ) 1번과 동일하게 10Byte의 데이터를 전송하게되면 Seq = 106 , Ack = 201 , Len = 10 을 담은 패킷을 전송한다.<br>
        이때 Seq가 5증가 한것을 볼수있는데 이는 총 전송할 데이터중 5Byte의 데이터는 이미 전송했기때문에 106 - 101(초기 Seq Num)번째의 패킷을 보내는 것이다.

        4 ) 2번과 똑같이 Seq = 201 Ack = 116 (106+10) 을 보내는데 이때 서버가 17Byte를 클라이언트에 전송하여 Len이 0이 아닌 17로 전송하였다.

        5 ) 이에 클라이언트는 Ack 116값을 응답받아서 정산적으로 수신된것을 알고 Seq = 116 Ack= 218(201+17) Len = 0 패킷을 전송하여 서버에게 17 Byte 크기의 데이터를 제대로 수신 받았음을 알리는 것이다.

    - TCP 데이터 전송 시 Window Size

        위의 예제에서는 한번의 전송 시마다 ACK를 받고 있다. 하지만 만약 크기가 큰 데이터를 보낸다고 가정하면 그만큼 ACK 응답을 기다리는 시간이 많아져 비효율적일수도 있다. 이를 해결하기 위해 ACK 응답 시 송수신자가 window size를 교환하게 된다.(위 세그먼트 구조를 보면 16Bit크기의 Window size가 있다.)
        송신측은 수신자의 Window Size만큼의 세그먼트를 합쳐서 보낼 수 있고 이는 세그먼트 하나를 보내고 ACK 응답을 기다릴 필요가 없어진다.

        __Window size란?__
        
        TPC 버퍼 제한 길이를 Window Size라고 한다.<br>
        서버쪽에서 클라이언트측의 데이터를 받으면 잘 받았다고 ACK를 보내는데 이 ACK에 Window Size 정보도 같이 보낸다.<br>
        클라이언트 쪽에서 ACK를 받고난 후 다음 데이터를 보내려고 할때 ACK에 적힌 Window Size와 MSS(MTU - (IP Header + TCP Header))를 비교한다.<br>

        ![image](https://github.com/9ony/9ony/assets/97019540/0be756d0-cb72-4a66-bcd3-f5724d0e1ce9)

        1 ) 데이터를 전송시에 수신측은 Window Size가 3500이라는 것을 인지하고 있다. 이는 위에 3-way handshake를 통해 연결을 할때 송수신측이 ACK 응답을 받을 때 서로 Window Size도 함께 보내기 때문에 알고있다.
        Window Size가 3500이기 때문에 송신측은 1KB(1024Byte)세그먼트 3개를 보내게 된다.

        2 ) 수신측은 데이터를 처리하고 전송받은 Seq Num + Data 크기를 ACK 응답 패킷을 보내게 된다. 이때 버퍼에서 처리한 Data 크기만큼 Window Size가 늘어난 것을 볼수있다.

        > Window Size는 그림에 나와있듯이 네트워크 지연상황 , 수신측의 버퍼 가용용량 , 데이터 처리속도에 따라 동적으로 설정된다.<br>
        만약 네트워크가 지연되서 세그먼트가 수신지까지 늦게 도착할경우 Window Size를 늘려서 수신지가 해당 세그먼트를 처리할 데이터의 크기를 늘려서 완화 시킬수도 있겠지만 Window size를 과도하게 늘려버리면 중간에 라우터가 과도한 데이터 때문에 처리를 할 수가 없게되어 결국 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생한다. 이러한 네트워크 내 혼잡 상태를 감지하고 송신 측의 전송 속도를 조절하여 네트워크 혼잡을 방지하는데 이를 TCP 혼잡제어라 한다.<br>
        또 송신측에서 데이터 전송속도가 수신측의 TCP 버퍼에 있는 데이터를 처리하는 속도보다 크다면 결국 버퍼에 데이터가 쌓여서 window size가 낮아지기 때문에 오버플로우가 발생하게 된다. 이럴때는 window size를 낮춰서 버퍼에 쌓이는 데이터량을 조절할 필요가 필요하다. 이런 방식을 TCP 흐름제어라 한다.<br>

        Window Size > MSS ? 서버에 데이터 전송 : 대기<br>
        
        <br>
        지연이 안될려면 서버쪽에서 TCP 버퍼에 있는 데이터를 빨리 READ 해서 비워야 한다.<br>
        네트워크 통신에서는 SEND 속도보다는 READ 속도가 더 빨라야 한다.<br>
        장애가 발생하면 프로세스 자체에서 송신속도나 수신시 데이터 처리속도 문제일 가능성이 크다.<br>
        Window Size를 조절하는데는 네트워크 상황 , 수신자의 처리속도 등 여러가지 요인 이에 따른 혼잡제어와 흐름을 제어하는 역할이 필요하다.

    - 4-Way handshake (연결을 끝내기 위한 동작)

        ![image](https://user-images.githubusercontent.com/97019540/237057187-ee4fa61e-3ffc-4949-b855-390e62c39488.png)

        1) 수신측 클라이언트가 서버와 연결을 끊기 위한 FIN 플래그를 보낸다.
        2) 서버는 수신측의 FIN 플래그에 대한 응답을 한다
        3) 서버도 클라이언트와 연결된 상태이기 때문에 클라이언트에 FIN 플래그를 보낸다
        4) 클라이언트는 서버측의 FIN 플래그에 대한 응답을 한다.<br>
            > 이때 클라이언트는 `Time Wait 상태`를 가지는데 아직 서버로부터 전송되지 않은 패킷이 남아있을수 있기 때문에 설정된 일정시간동안은 데이터를 수신한다.

### TCP의 제어기능 3가지
위 TCP 데이터 전송과정에서 간략하게 흐름제어와 혼잡제어를 설명했다. 또 TCP에는 오류를 제어하는 기능도 있는데 차례대로 정리해 보겠습니다.

- __흐름제어 (Flow Control)__

    > 흐름제어에는 대표적으로 2가지 기법인 Stop and Wait , Sliding Window 가 있다.
    - __Stop and Wait__

    ![image](https://github.com/9ony/9ony/assets/97019540/f0eeef6b-d96b-4fca-a022-698d702b147c)

    Stop And Wait는 데이터 요청후 ACK를 응답받는 것이고 데이터 요청한 후 일정 시간동안 ACK응답이 안오면 재요청을 하게된다.
    Stop And Wait는 안정적인 데이터 전송이 이루어지지만 패킷 한개당 ACK 응답을 받아야 다음 패킷을 보내기 때문에 상당히 비효율적이다.

    - __Sliding Window__

    ![image](https://github.com/9ony/9ony/assets/97019540/72e67030-2285-42be-b7b4-6dec9ae92455)

    Sliding Window는 Stop And Wait와는 다르게 초기 연결시에 송신자와 수신자가 Window Size를 서로 공유하게 된다.<br>
    그래서 해당 사이즈만큼의 세그먼트는 응답코드를 받지않아도 미리 송신할 수 있게되고,<br>
    수신측은 해당 송신측에 자신이 수용할 수 있는 세그먼트크기 (Window Size)를 지속적으로 송신측에 전달한다.<br>
    
    > 그림에 rwnd 라고 있는데 추가적으로 awnd 와 cwnd 라는 크기 관계식이 존재한다.<br>
    rwnd 수신측 가용가능한 버퍼용량이고 cwnd는 네트워크상에서 혼잡도를 고려하여 설정한 윈도우 크기다.<br>
    awnd는 송신측에서 전송가능한 최대 윈도우 크기이며 이는 rwnd,cwnd중 작은값으로 설정된다. min(rwnd,cwnd)
    
> 이처럼 TCP에서는 수신 측이 수용 가능한 데이터 양을 나타내는 Window Size를 사용하여 흐름 제어를 수행한다.<br>
수신 측은 Window Size 값을 송신 측에게 전달하여, 송신 측은 해당 값에 따라 데이터를 전송하는 속도를 조절하고<br>
수신 측의 버퍼 용량과 수신 가능한 처리 속도에 따라 Window Size가 동적으로 조정되어 데이터의 효율적인 전송이 이루어진다.<br>

- __혼잡제어 (Congestion Control)__

    송신측과 수신측이 데이터를 주고 받을때 중간에 여러 네트워크 망(라우터)을 거치게 된다.<br>
    데이터 송신시에 특정 라우터에 패킷이 과도하게 몰리게 된다면 라우터의 처리속도에 비해 라우터 버퍼의 크기는 유한하기 때문에 패킷이 쌓이게 되면서 더이상 패킷이 들어올 수 없어서 패킷이 유실된다.<br> 
    또 이 문제를 해결하기위해 라우터의 버퍼 용량을 늘리게 된다면 그만큼 패킷이 머무는 시간이 증가할수 있어서 전송이 지연되며 타임아웃 시간보다 늘어나게되면 계속해서 재전송 요청을 하기때문에 패킷량이 늘어나 악순환이 반복된다.<br>
    이에 따라 윈도우 사이즈를 조정해야 되는데 이를 혼잡제어라 한다.<br>
    흐름제어는 송신자와 수신자의 전송속도 즉, 윈도우 사이즈를 다뤗다면 혼잡제어는 보다 넓은 전송문제를 관리하게 된다.

    > 혼잡을 제어하는 알고리즘에는 수많은 알고리즘이 존재하는데 기본적인 AIMD , Slow Start , Congestion Avoidance , Fast Retrasmit , Fast Recovery 알고리즘과 현재 대표적으로 사용되고 있는 혼잡제어 알고리즘인 TCP Cubic , TCP New Reno이 있다.<br>
    네트워크 상황과 요구사항에 따라 다양한 알고리즘이 선택적으로 사용된다.

    - AIMD (Additive Increase & Multiplicative Decrease)

    > AIMD 는 직역하면 합증가 곱감소이다. RTT(Round Transmit Time)당 Congestion Window를 1씩 증가하고 만약 혼잡이 발생하면 cwnd*=0.5를 하여 반으로 줄이는 것이다.<br>

    __AIMD 그래프__<br>
    ![image](https://github.com/9ony/9ony/assets/97019540/f839d0fd-ca5c-4222-a7b1-2092685eaa91)

    단점으로는 통신속도 즉 window size가 느리게 증가함.

    - Slow Start

    > Slow Start는 느린시작인데 cwnd값을 1부터 시작하는것이다. 하지만 증가폭은 RTT당 cwnd값을 두배로 증가되면서 cwnd 사이즈를 빠르게 증가시킨다. 이는 AIDM의 윈도우 크기가 느리게 증가하는 것을 보완한 알고리즘이다.<br>
    수신 받은 ACK 당 cwnd = cwnd + 1MSS<br>
    즉, 송신자가 cwnd가 2일때 2개의 세그먼트를 보내면 수신자가 2개의 세그먼트를받으니 +2 증가되는 것이다.<br> 그럼 cwnd는 4가되고 그다음에 4개의 세그먼트를 전송하면 세그먼트 개수만큼 증가하니 +4가 되어 8이 되므로 2배씩 증가하게 된다.<br>

    __Slow Start 그래프__<br>
    ![image](https://github.com/9ony/9ony/assets/97019540/f4b7ae25-c9eb-4c42-937b-035c7825b555)

    ssthresh란 slow start시에 cwnd값이 지수증가하게 되는데 이때 특정 수치에 도달하게되면 cwnd가 1이된다 이때 이 특정 수치를 ssthresh라 한다.<br>
    Slow Start는 ssthresh까지 cwnd가 지수증가하는 것이라고 볼 수 있다.

    - Congestion Avoidance

    > Congestion Avoidance란 slow start 시에 ssthresh에 도달하면 cwnd를 1로 설정하지 않고 RTT마다 cwnd가 1씩 천천히 선형적으로 증가시키는 것이다.<br>
    * 이는 TCP Reno 알고리즘 기준이고 다른 알고리즘은 증가량이 다르다고 한다.<br>

    __Congestion Avoidance 그래프__<br>
    ![image](https://github.com/9ony/9ony/assets/97019540/b752b33c-4777-4a72-8dfc-47eb83886034)

    그림과 같이 slow start가 ssthresh값이 8인 시점에 Congestion Avoidance(혼잡회피) 단계가 진행되어 cwnd값이 cwnd = cwnd + MSS * (MSS/cwnd)로 증가 하게 됨. <br>
    해당 식이 의미하는 것은 MSS는 세그먼트의 데이터 최대 크기인데 1Byte이라고 가정하자.<br>
    그러면 cwnd가 8이니까 1*(1/8)= 0.125씩 증가하게 되는데 cwnd가 8Byte이고 세그먼트 크기가 1Byte이니까 응답코드가 RTT당 8개 올것이므로 결과적으로 RTT당 1이 증가하게된다. (제가 이해한 내용입니다.)

    - Fast Retransmit<br>

    > Fast Restransmit는 빠른 재전송 기법이다.<br> 
    우선 빠른 재전송을 알아보기전에 RTO에 대해 간단하게 집고 넘어가겠다.<br>

    __RTO란?__<br>
    Retransmisstion TimeOut으로 재전송 타임을 설정한 시간 값이라 보면 된다.(InitRTO = 운영체제 기본값 설정)<br>
    해당 시간을 초과하면 패킷이 손실됬다고 판단하여 재전송을 요청한다.

    ![image](https://github.com/9ony/9ony/assets/97019540/e2decbcb-5a2f-4c3d-9350-a3bb932b8369)

    > 빠른 재전송은 재전송을 하기위해 RTO 시간동안 기다리지 않고 중복 ACK가 3번이상 온다면 바로 재전송 요청을 보내는 방식이다. 
    즉 TimeOut시간에 의존하지 않고 중복 ACK응답이 3개가 오면 재전송을 보내는 것이다.
    
    > __추가 설명!__ <br>
    Seg3 or Seg6 이라고 표시한 이유는 나중에 오류제어 방식이 어떤 방식인지에 따라 달라진다 (GBN or SR)

    - Fast Recovery<br>
    > Fast Retransmit 후 Slow Start 아닌 혼잡회피상태에서 전송하는 기법이다.<br>
    여러 세그먼트 손실 시 세그먼트 하나씩 복구되므로 모든 패킷 ACK 수신까지 대기한다.

    ![image](https://github.com/9ony/9ony/assets/97019540/53c3f280-73b3-4cc4-b13d-168dd42262be)

    그림과 같이 Fast Recovery는 3개의 ACK가 중복되서 수신됬을경우 cwnd값을 1로 줄이지 않고 반으로 줄여서 바로 Congestion Avoidance상태로 cwnd를 1씩 증가시킨다.<br>
    더 구체적으로는 Fast Recovery 상태에 들어가게되면 ssthresh값은 반으로 줄어들고 cwnd값은 반으로 줄어든 ssthresh값 + 3을 더해주는데 3을 더해주는 이유는 `중복된 3개의 ACK`의 영향을 고려한 값이라고 보면된다.
    <br>
    중복된 3개의 ACK를 수신하여 Fast Recovery 상태에서 그전에 보낸 데이터에 대한 중복 응답이 3개 보다 많을 경우도 있을것이다. 그러면 초과된 중복 ACK당 cwnd가 1씩 증가한다.<br>
    초과된 중복 ACK를 받은 후에는 cwnd를 1씩 증가시키며 세그먼트를 다시 전송한다.<br> 

    ![image](https://github.com/9ony/9ony/assets/97019540/38b71651-2e11-4917-adde-0f05ea64d0e9)
    
    __Fast Recovery 시나리오 설명__<br>
    송신자는 24번 세그먼트 부터 33번 세그먼트까지 보냈는데 중간에 28번 세그먼트가 손실됬다.<br>
    수신자 입장에서는 27번까지 세그먼트를 정상적으로 받은 후에 데이터를 처리하여 ACK를 보낸다.<br>
    송신자는 4MSS크기의 버퍼를 확보했으니 그다음 34~37까지 세그먼트를 전송한다<br>
    수신자는 28번 세그먼트가 손실되서 수신받지 못했고 그 이후 29,30, 31번까지 세그먼트가오면 순서가 맞지않기 때문에 중복된 28번의 ACK를 3번 보낼것이고 송신자가 Fast Retransmission을 수행하여 다시 28번 세그먼를 재전송한다.<br>
    이 시점에 중복된 3개의 ACK가 왔으니 송신자는 ssthresh를 cwnd/2값으로 줄이고 cwnd는 반으로 줄여진 ssthresh값에 3을 더한 8로 설정된다.<br>
    이후 32,33에 대한 응답이 도착하여 중복된 ACK 2개가 더 도착하면서 cwnd가 ACK당 1씩오르게 되니 cwnd는 10으로 된다.(위 상황과 같이 버퍼크기를 확보했으니 38,39 세그먼트도 전송됨)<br>
    그럼 수신자는 28번 세그먼트까지 정상적으로 수신받아서 현재 37번 세그먼트까지 전송받게 되어 38ACK를 보내게 된다.<br>
    송신자는 드디어 새로운 ACK (NEW ACK)를 전송받았기 때문에 cwnd가 ssthresh값인 5로 설정되어 다시 혼잡회피상태가 된다.

    [Fast Recovery 참고 링크](https://ai-com.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCP-Congestion-Control-2-%EA%B8%B0%EB%B3%B8-%EB%8F%99%EC%9E%91)

    [Fast Recovery cwnd변화 세그먼트흐름 그림 참고](https://www.isi.edu/nsnam/DIRECTED_RESEARCH/DR_WANIDA/DR/JavisInActionFastRecoveryFrame.html)
    
- __오류제어 (Error Control)__

> TCP 오류제어는 수신자가 세그먼트 전송과정에서 중간에 손실됬거나 변경된 사항이 없는지 검출하고 재전송하는 역할을 한다.

  - __오류 검출__<br>

  > 우선 오류를 처리하기 전에 오류가 발생했는지 여부부터 확인해야 한다.<br>
  데이터 무결성을 검사하기 위해 대표적으로 CRC(Cycle Redundancy Check)가 사용되고 그 외로 CheckSum 와 Parity Bit를 이용한 방식이 존재한다.<br>

    - __Parity Bit__

        패리티 비트는 전송하고자 하는 데이터(2진수)에 1을 더하여 전송하는 방법으로 2가지 방법이 있는데 짝수 패리티 비트와 홀수 패리티 비트이다. <br>짝수 패리티 비트 ( Even Parity Bit)는 해당 데이터가 만약 0110001을 보낸다하자 그러면 1의 개수가 5개이다 그러면 패리티 비트 1이 추가되어 01100011이 되어 1의 개수가 짝수개가 되는 것이다. <br>

        ![image](https://github.com/9ony/9ony/assets/97019540/4e726441-1b14-4485-82a2-556cf130e7e7)

        위 그림 처럼 만약 중간에 데이터가 변경되어서 4번째 비트가 0이아닌 1이되어 전송되었다면 1의 개수가 짝수개가 아니므로 해당 데이터에 문제가 있음을 감지 할 수 있다.<br>

        ![image](https://github.com/9ony/9ony/assets/97019540/d5864ce2-0247-4a08-b854-ee0994f48cb3)

        하지만 패리티비트의 단점으로는 위 그림처럼 데이터에 2개의 비트가 변경되었을지 오류 검출을 못한다.<br>

        홀수 패리티 비트 (Odd Parity Bit)도 마찬가지로 홀수로 맞추는 것이므로 기존에 3개의 1이 있었으니 패리티 비트는 0이 된다. 수신자는 이 패리티 비트를 확인하여 데이터가 오류가 있는지 검출할 수 있다.

    - __Check Sum__

        parity bit의 오류검출 능력을 향상시키기 위해서 개발된 방법

        1.TCP 세그먼트 데이터에 패딩을 추가하여 데이터 길이가 16비트(2바이트)의 배수가 되도록 맞춤

        2.TCP 체크섬 필드를 0으로 설정

        3.TCP 세그먼트 데이터와 TCP 헤더를 16비트단위로 나누어서 모두 더한다.

        4.만약 덧셈 연산 중에 16비트를 초과하는 경우에는 초과한 비트를 다시 더해줌

        5.계산된 결과에 1의 보수 (비트 반전).

        6.계산된 값 = 체크섬

        [체크섬 계산 방법](https://securitynewsteam.tistory.com/entry/TCP%EC%B2%B4%ED%81%AC%EC%84%AC-%EA%B3%84%EC%82%B0%EB%B0%A9%EB%B2%95)

        하지만 체크섬도 발생하는 모든 오류를 검출할 수는 없다. 예를 들어 04 bb 25 e0 7a 라는 5byte데이터를 보냈다고 가정하자. 하지만 송신측에서 03 bc 25 e0 7a로 받았다. 첫번째와 두번째바이트가 -1 , +1씩 되었어도 결국 합은 같기 때문에 오류를 검출하는데 문제가 생긴다.

    - __CRC__

        입력 데이터에 대해 다항식 연산을 수행하여 체크섬 값을 계산  (보편적으로 가장 많이 쓰인다.)
        <br>

        CRC는 다항식으로 표현되는 제어 비트를 사용하여 입력 데이터에 추가되는 오류를 감지<br>
        송신자는 입력 데이터와 제어 비트를 이용하여 체크섬 값을 계산하여 전송한다.수신자는 동일한 다항식을 이용하여 수신된 데이터에 대한 체크섬 값을 계산하고, 송신자가 전송한 체크섬 값과 비교
        체크섬 값이 일치하지 않는다면 데이터에 오류가 있는 것으로 간주한다.<br>

        체크섬에 대해 깊게 기술하는것은 다음에...

        [CRC란?](https://depotceffio.tistory.com/entry/CRC%EC%9D%98-%EB%9C%BB%EA%B3%BC-%EA%B3%84%EC%82%B0-%EB%B0%A9%EB%B2%95)

  - __재전송 기반__

  ARQ 방식 사용 ( GBN,SR,Stop and Wait 등이 있고 아래서 설명하겠습니다.)<br>
  중복 ACK를 통한 패킷 손실 감지 후 재전송<br>
  타임아웃 기반으로 해당 데이터에 대한 ACK를 받지 못하면 데이터가 정상적으로 전송되지 않았다 판단 후 재전송<br>
  NACK 부정응답번호로 인한 재전송<br>
  즉, 수신측이 송신측에게 재전송을 요청함 (수신자 피드백 방식)<br>

  > 재전송 기반의 에러제어 방식도 결국 위의 에러검출 또는 타임아웃을 거친 후 진행된다. ACK를 보낼지 NACK를 보낼지도 결국 에러검출 과정을 거친후 데이터가 정상적이지 않으면 NACK를 보내서 해당 데이터를 재전송 받는 것이다.<br>

    - __Go Back N ARQ__<br>
        한번에 여러 개를 보낸후 하나의 긍정 확인응답(ACK)을 받고 후속 데이터 전송<br>
        NAK(부정 확인응답)를 수신할 때까지 계속하여 데이터를 송신<br>
        슬라이딩 윈도우 (Sliding Window) 방식 이라고도 불리움<br>
        분실 시 분실된 시점부터 다시 데이터를 보냄<br>

        ex) 만약 1~6개의 패킷을 보냈는데 중간에 3번 패킷이 손실되서 전송이 안됬다면 3456을 다시보낸다.

    - __Selective Repeat ARQ__<br>
        오류가 발생된(NACK) 프레임 이후 또는 오류 발생된 프레임 만을 재전송 (GBN의 단점 보완)<br>
        오류가 발생된 데이터만 받기 때문에 데이터 순서를 위해
            재정렬을 수행해야 하며, 별도의 버퍼를 필요<br>
            즉, 구조가 복잡하고 GBN보다 비용이 비싸다.<br>

        ex) Go Back N과 다르게 만약 중간 3번패킷이 손실됬다면 3번패킷만 재전송한다.<br>
        이렇게 되면 124563의 순서로 도착하기 때문에 정렬과정이 필요한 것이다.<br>

    - __Stop and Wait ARQ__

        위 흐름제어에서 설명하여 생략. 해당 흐름제어 자체가 에러제어도 같이한다고 보면됨.

  __🎇 Go-Back-N ARQ와 Selective Repeat ARQ가 TCP에서 주로 사용된다!!__
  
   http://www.ktword.co.kr/test/view/view.php?m_temp1=1299


### UDP(비연결형 통신) 프로토콜

- __UDP 특징__<br>
비연결형 서비스로 독립적인 통신을 한다. 즉, TCP처럼 3way handshake를 통한 논리적 경로를 설정하지 않는다.<br>
멀티캐스트와 브로드캐스트 등 일 대 다 통신지원<br>
TCP에 비해 비용(오버헤드)이 적어 속도가 빠르다. (UDP 헤더 크기는 8Byte)<br>
흐름,혼잡 제어등이 기본적으로 지원하지 않는다. 즉, 안정성과 신뢰성을 보장하지 않음 (ACK , TimeOut , ARQ 지원 X)<br>
UDP는 오류 보고를 위해 ICMP에 의존한다.<br>

- __UDP 헤더 구조__
![image](https://github.com/9ony/9ony/assets/97019540/16ccbae5-fadb-488b-adeb-bf787ac1543d)

  Source Port : 출발지 포트 번호<br>

  Destination Port : 목적지 포트 번호<br>

  Length : 헤더 + 데이터의 길이<br>

  Check Sum : 데이터 오류검사를 위한 필드 하지만 `UDP는 필수가 아니다`<br>
  체크섬을 이용한 기본 오류검사 메커니즘만 이용한다.


- __UDP를 활용하는 서비스__
UDP는 신뢰성있는 데이터가 아닌 연속성이 중요한 서비스에 주로 사용된다.<br>
주로 실시간 스트리밍 서비스와 게임등에서 활용된다.<br>
ex) 온라인 게임,DNS,DHCP,NTP,VOIP,화상 채팅 등..


UDP로 신뢰성을 보장받기 위해 Reliable UDP (RUDP)가 존재한다.<br>
HTTP1.x과 HTTP2는 TCP기반으로 작동되었지만 HTTP3부터 UDP기반의 프로토콜 QUIC을 사용한다.<br>
[QUIC 프로토콜 참고자료](https://bentist.tistory.com/36)

### 전송계층 보안 프로토콜

해당 프로토콜들은 TCP/IP 스택 위에서 주로 다루게 된다.

- SSL

    네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고
    다른 시스템으로 파일을 복사할 수 있도록 해주는 응용 프로그램 또는 그 프로토콜<br>

    `SSL은 POODLE, DROWN 등의 취약점이 발견되어 현재 사용되지 않는다!!`

    [SSL 참고링크](http://www.ktword.co.kr/test/view/view.php?m_temp1=2524)

- TSL

    TLS는 SSL의 직접적인 후속이며 이제 모든 버전의 SSL이 더 이상 사용되지 않습니다.<br>
    대부분의 경우 SSL 및 SSL/TLS라는 용어 모두 TLS 프로토콜과 TLS 인증서를 나타냄<br>

### SSL/TLS 의 작동 방식

SSL은 개인정보 보호를 제공하기 위해, 웹에서 전송되는 데이터를 암호화 한다.<br>
따라서, 데이터를 가로채려해도 거의 복호화가 불가능하다.<br>
SSL은 클라이언트와 서버간에 핸드셰이크를 통해 인증이 이루어진다.<br> 
또한 데이터 무결성을 위해 데이터에 디지털 서명을 하여 데이터가 의도적으로 도착하기 전에 조작된 여부를 확인한다.<br>

### SSL과 TLS차이점

- SSL/TLS 핸드셰이크

    핸드셰이크는 브라우저가 서버의 SSL 또는 TLS 인증서를 인증하는 프로세스<br>
    양 당사자를 인증한 다음 암호화 키를 교환<br>

    >SSL 핸드셰이크는 명시적 연결  TLS 핸드셰이크는 암시적 연결 <br>
    TLS는 추가 단계를 제거 + 총 암호 그룹 수를 줄여서 프로세스 속도 증가<br>

- 알림 메시지

    SSL 및 TLS 프로토콜은 알림 메시지를 통해 오류와 경고를 전달<br>

    SSL은 경고와 치명적이라는 두 가지 알림 메시지 유형<br>
    경고 알림은 오류가 발생했지만 연결 유지<br>
    치명적 알림은 연결을 즉시 종료<br>

    TLS에는 닫기 알림이라는 추가 알림 메시지 유형이 존재함<br>
    닫기 알림은 세션 종료를 알림 <br>

    > SSL 알림 메시지는 암호화 TLS 알림은 암호화됨<br>
    TLS는 알림메세지 기존 경고와 치명적 + 닫기알림 존재<br>

- 메시지 인증

    SSL과 TLS 모두 메시지의 진본성과 무결성을 확인을 위한 메시지 인증 코드(MAC)를 사용(암호화 기술)<br>
    레코드 프로토콜은 보안 키를 사용하여 MAC을 고정 길이 코드로 생성하고 원본 메시지에 첨부<br>

    >SSL 프로토콜은 MAC생성에 MD5 알고리즘 사용 (현재는 사용X)<br>
    TLS는 더 복잡한 암호화와 보안에 해시 기반 메시지 인증 코드(HMAC) 사용 <br>

- 암호 그룹

    암호 그룹은 브라우저와 서버 간의 정보를 암호화하기 위한 키를 생성하는 알고리즘 모음입니다.<br>
    일반적으로 암호 그룹에는 키 교환 알고리즘, 검증 알고리즘, 대량 암호화 알고리즘 및 MAC 알고리즘이 포함됩니다.<br>

    >보안 문제로 인해 TLS의 여러 알고리즘이 SSL에서 업그레이드<br>

[SSL과 TLS 차이점 참고자료](https://aws.amazon.com/ko/compare/the-difference-between-ssl-and-tls/) ,
[SSL과 TLS 차이점 참고자료2](https://www.ssl2buy.com/wiki/ssh-vs-ssl-tls)
### 전송계층 역할 정리

전체 메시지의 프로세스 대 프로세스 전달에 대한 책임을 가짐. 전체 메시지가 완전하게 바른 순서로 도착하는 것을 보장.<br>
네트워크 층은 개별적인 패킷의 종단 대 종단 전송을 담당 기능<br>

포트 주소 지정 : 포트 주소를 포함, 프로세스에 전달<br>
분할과 재조립 : 전달가능한 세그먼트 단위로 나눔, 응답번호(seq,ack)를 통해 재조립 및 손실여부 판단<br>
연결 제어 ,흐름 제어 ,오류 제어 기능<br>

## 세션 계층 (Session Layer)

이 계층은 통신 세션의 수립, 유지 및 종료를 관리하며, 데이터의 송수신을 동기화하는 역할을 한다.<br>

🔍 세션이란?
네트워크에 있어서 세션이란, 통신의 시작부터 종료까지를 일컫는다.<br>
클라이언트와 서버에서 통신을 하는 경우 클라이언트에서 서버로 접속한 시점에서 세션이 시작되고 서버에서 끊어지면 세션이 종료된다.<br>
이 흐름을 관리하는 것을 세션 관리라고 한다.<br>

즉, 세션 계층(Session Layer, 5계층)에서는 응용 프로그램 간의 통신을 하기 위한 세션을 운영체제를 통해 확립, 유지, 중단하는 작업을 수행한다.<br>
응용 프로그램들 간의 접속을 설정, 유지하고 끊어질 경우 데이터를 재전송하거나 연결을 복구한다.<br>

### 세션계층 주요 기능

- 세션의 설정, 관리, 해제 (session manage)
    - 세션을 설정 및 해제하는 기능 

- 대화 관리
    - 통상, `토큰을 사용함으로써 대화를 관리`<br>
        성립된 세션을 통한 상호 대화 관리를 하는 양단간 응용 개체를 위해 토큰 개념이 정의됨<br>
        누가 언제 통신하였는지를 결정하며 토큰을 교환함으로써 구현<br>
        프로세스는 토큰을 가졌을 때 전송할 수 있음<br>

    - 여기서, 토큰은, 어떤 서비스의 실행을 기동하는 권리를 표현하는 것<br>

- 다중화
    - `여러 세션들을 묶어, 1개의 같은 전송계층 접속을 사용`할 수 있음 (효율 증가)<br>
        반대로 `1개 세션이 속도 등을 위해 다수의 전송계층 접속들을 사용`할 수도 있음<br>

    - `상향,하향 다중화가 가능`<br>

- 대화 단위별 그룹화 (check point, synchronization)
    - `점검점,동기점 등을 삽입`함으로써 `메세지를 대화 단위`로 그룹화 함 (동기화 지점 설정)<br>
    - 중간에 에러 발생 시 중단된 `대화 단위 시점부터 재전송`함<br>

- 데이터의 범주화 교환
    - OSI는 데이터를 4가지 범주로 구분한 바 있음<br>
        정보 데이터, 급송 데이터, 제어 데이터, 세션 파라미터 협상에 사용되는 데이터<br>

- 전송모드 설정
    - 양방향 동시(전이중), 양방향 대체(반이중) 및 단방향(단방향)의 세 가지 대화 유형을 제공<br>

### 세션계층 주요 프로토콜

- NetBIOS

로컬 네트워크에서 프로세스 간 통신을 위한 프로토콜입니다.<br>
NetBIOS는 주로 Microsoft Windows 운영 체제에서 사용되며, TCP/IP 프로토콜 스택 위에서 동작합니다.<br>
파일 공유, 프린팅, 이름 서비스 등 다양한 서비스를 제공하는 데 사용됩니다.<br>

- NetBIOS 기능

    - 네임 서비스 (이름 서비스)<br>
        이름 : 16 바이트의 문자 or 숫자 <br>
        대문자 컴퓨터 이름 (15 바이트) + name type (1 바이트)
        NetBIOS 이름공간은 비계층 구조 <-> DNS는 계층적

    - 세션(Session) 모드 서비스<br>
        두 컴퓨터가 통신할 수 있는 연결을 성립시키고, 보다 큰 메시지가 처리될 수
            있게 하며, 통신 에러의 발견과 회복을 제공.

    - 데이터그램(Datagram) 모드 서비스<br>
        데이터그램 모드는 비연결형(connectionless, 각 메시지가 독립적으로 전송)으
            로, 메시지가 보다 작으며 응용 프로그램이 통신 에러의 발견과 회복을 수행.<br>
            또한 메시지를 LAN의 모든 컴퓨터에 전송시키는 브로드캐스트(방송)을 지원.

### 세션 계층 역할 정리

사용자 위주의 논리적인 연결 서비스 제공<br>
전송모드 설정 (반이중, 전이중, 단방향, 병렬, 직렬, 동기, 비동기)<br>
대화와 동기를 위한 데이터 교환 관리<br>
토큰 (Token: 특정 서비스 요구 권리)<br>

## 표현 계층 (Presentation Layer)

다른 시스템(상대 시스템)이 다른 데이터 표현방식을 사용한다면 데이터 값이 서로 표현방식이 다르기 때문에 값이 달라질수도 있다.<br>
그래서 서로 데이터를 통일된 구문으로 교환,변환하여 읽어야 하는데 이때 데이터를 변환하거나 해석하는 역할을 하는 계층이 표현계층이다.
### 표현계층 주요 기능

표현양식을 공통형식으로 변환<br>
송신자에서 온 데이터를 해석하기 위한 응용계층 데이터 부호화, 변화<br>
수신자에서 데이터의 압축을 풀수 있는 방식으로 된 데이터 압축<br>
데이터의 암호화와 복호화<br>
 > (MIME 인코딩이나 암호화 등의 동작이 표현계층에서 이루어짐. EBCDIC로 인코딩된 파일을 ASCII 로 인코딩된 파일로 바꿔주는 것이 한가지 예임)
가상 터미널 규약<br>
 > 라인, 스크린 길이,커서,페이지 모드 등이 상호간에 다르므로 가상 터미널을 만든다.

### 표현 계층에서 사용되는 기술적인 표준과 알고리즘

- 문자 인코딩(Encoding)<br> 
문자 인코딩은 텍스트 데이터를 컴퓨터에서 처리 가능한 이진 형식으로 변환하는 방법<br>
일반적으로 사용되는 문자 인코딩 방식으로는 ASCII, UTF-8, UTF-16, ISO-8859 등이 있음<br>

- 데이터 압축(Compression)<br>
데이터 압축은 데이터의 용량을 줄이기 위해 사용되는 기술<br>
압축 알고리즘으로는 주로 Deflate, LZ77, LZ78, Gzip 등이 사용<br>
데이터 압축은 네트워크 대역폭을 절약하고 전송 속도를 향상시키는 데 도움이 된다.<br>

- 암호화(Encryption)<br>
암호화는 데이터의 기밀성을 보호하기 위해 사용되는 기술<br>
대칭키 암호화와 비대칭키 암호화가 일반적으로 사용되고 대표적인 암호화 알고리즘으로는 AES(Advanced Encryption Standard), RSA, DES(Data Encryption Standard) 등이 있다.<br>

- 이미지 및 동영상 압축<br>
이미지와 동영상 데이터의 압축은 JPEG, PNG, GIF와 같은 이미지 포맷, 그리고 MPEG-2, MPEG-4, H.264, HEVC(H.265)와 같은 동영상 압축 표준이 사용<br>
이러한 압축 기술은 이미지와 동영상 파일의 용량을 줄이고 전송 및 저장 효율성을 향상시켜준다.<br>

- 데이터 형식 변환<br>
표현 계층은 데이터 형식 변환이 필요한 경우에도 작동한다.<br>
XML(Extensible Markup Language)과 JSON(JavaScript Object Notation) 사이의 변환은 XML 파서와 JSON 직렬화 기술을 사용하여 수행될 수 있다.<br>

### 표현계층 역할 정리

데이터의 형식 변환, 데이터 압축, 암호화, 인코딩 등의 기능을 제공하여 응용 계층에서 사용하는 데이터를 하위 계층과 상호 운용 가능한 형태로 변환해준다.
표현 계층은 데이터 표현에 관련된 프로토콜 및 알고리즘을 사용하여 데이터의 안전성과 효율성을 보장하는 역할


## 응용계층 (Application Layer)

응용계층은 OSI7 Layer에서 최상위 계층에 속하고 사용자(Client)에 가장 가까운 계층이다.<br>
해당 계층에서 메일 시스템,파일 시스템,앱 서비스,웹 등 우리가 사용하는 서비스가 작동되고,<br>
사용자와 네트워크 상호작용을 위한 인터페이스를 제공한다.

> 우리가 지금 사용하는 네트워크 모델인 TCP/IP 5 Layer가 표준으로 사용됨.<br>
TCP/IP 5 Layer에서는 Application Layer가  Session Layer,Presentation Layer를 합쳐 통틀어서 Application Layer이다.

### 응용계층 서비스와 프로토콜

- 웹 서비스
    - HTTP(TCP 기반)
        Web 표준 프로토콜 1.0 -> 1.1 -> 2.0 -> 3.0 (3.0은 UDP 기반! QUIC프로토콜 사용)
    - HTTPS
        TLS/SSL 레이어 위에서 작동하는 HTTP와 보안계층과 결합한 프로토콜, 443포트 사용

    [HTTP,HTTPS 참고자료](https://aws.amazon.com/ko/compare/the-difference-between-https-and-http/)

- 전자우편 서비스
    - SMTP (Mail System Protocol)<br>
        메일 전송 시에 사용되는 프로토콜로 데이터 형태는 거의 대부분을 지원한다.<br>
        TLS를 통한 보안처리 가능<br>
        ex) 기본포트 25(보안문제 때문에 방화벽에 막힐 가능성 큼),<br>
        TLS을 이용한 암호화 포트 465(레거시) -> 587(현재 가장 많이 사용)      

    - IMAP<br>
        SMTP가 메일서버에 전송한 메일을 읽어올 때 사용된다.<br>
        메일서버와 동기화해서 읽어오는 방식<br>
        메일서버 용량이 작을 경우 잘 사용하지 않음<br>

    - POP , POP3<br>
        SMTP 메일서버에서 메일을 현재 디바이스에 저장할때 사용<br>
        메일 저장 시 서버에서 메일이 삭제됨<br>
        메일서버와 동기화하는 방식이 아님<br>
        메일서버 용량이 작다면 개인이 메일을 저장하는 방식으로 좋다<br>
    > 간단하게 SMTP는 전송 & IMAP(서버와 동기화) , POP3(디바이스 저장)는 수신 시 사용되는 프로토콜

    [SMTP , IMAP , POP3 참고자료](https://www.cloudflare.com/ko-kr/learning/email-security/what-is-smtp/)
    [SMTP , IMAP , POP3 참고자료2](https://www.socketlabs.com/blog/smtp-or-imap/)

- 파일 전송 서비스
    - FTP (File Transfer Protocol)
        TCP/IP기반으로 파일전송시 사용되는 프로토콜이다.<br>
        FTP는 Active모드와 Passive모드 둘로 나뉜다.<br>
        둘의 공통점으로는 클라이언트는 FTP SERVER(파일시스템 서버)에는 21번 포트로 연결 요쳥<br>
        
        Active Mode : 해당 모드는 서버가 20번포트를 이용하여 클라이언트에 데이터 채널 연결 요청을 한다.<br>

        Passive Mode : 해당 모드는 서버가 1024번 이상의 임의의 포트를 클라이언트와 21번 포트를 통한 연결 시에 어떤 포트로 데이터 채널 연결 요청을 할지 포트를 알려주면 클라이언트가 다시 데이터 전송을 위한 포트에 연결 요청을 한다.<br>

        두 모드의 차이점은 Active Mode는 데이터 전송을 위한 포트가 20으로 고정되어 있어서 클라이언트가 방화벽 or 보안으로 인해 해당 포트의 접근을 막을 수도 있다.<br>
        Passive Mode는 파일 서버에서 데이터 채널 포트를 어떤 포트를 사용할 지 범위를 설정하여 클라이언트에게 접속한다.<br>

    - SFTP (Secure File Transfer PRotocol)
        SSH를 이용한 파일전송 시스템 , SSH의 확장 프로토콜<br>
        파일을 암호화하여 전송<br>

    [FTP,SFTP 참고자료](https://peemangit.tistory.com/66)

- 네트워크 관리 서비스
    - SNMP (Simple Network Management Protocol)
        - 실시간으로 상태를 모니터링 및 설정을 위한 프로토콜
        - 시스템이나 네트워크 관리자로 부터 네트워크에 장치들을 모니터링 및 환경설정
        - 메세지는 단순 요청과 응답으로 교환되기 때문에 UDP를 사용한다.
        - 관리의 편의성이 있지만 DoS, 버퍼 오버플로우, 비인가 접속 등 보안에 취약점이 있다.
        - 인증 및 인가와 같은 보안과 원격 관리 등의 부분을 강화에 초점을 둔 SNMPv3까지 등장함.
    
    [SNMP 참고자료](https://aws.amazon.com/ko/blogs/mt/snmp-monitoring-using-amazon-cloudwatch-and-elastic-logstash/)

    - Syslog
        - 컴퓨터 메시지 로깅에 대한 표준
        - 다른 유형의 다양한 시스템으로부터 로그 데이터를 중앙 저장소에 통합
        - 로그 메시지를 수집하고 관리하기 위한 프로토콜.

    [SysLog 참고자료](https://www.ibm.com/docs/ko/db2/11.1?topic=logs-configuring-system-error-event-log-syslog)

- 원격 서비스
    - TELNET
        - 터미널 장치 및 터미널 지향 프로세스에 대한 표준 메소드를 인터페이스에 제공
        - 일반적으로 원격 호스트에 로그인하도록 하는 터미널 에뮬레이션 프로그램에 사용
        - 다른 프로토콜을 제어하기 위한 채널을 구축할 때 사용하기도 함
        - 터미널 대 터미널 통신 또는 프로세스간에 사용한다.
        - 텍스트 지향 메세지(데이터를 일반 텍스트로 변환)이므로 id,password 같은 데이터가 노출될 위험이 있다.

    - SSH (Secure SHell)
        - TCP기반의 보안통신을 지원 (22번 포트사용)
        - rsh, rcp, rlogin, rexec, telnet, ftp 등 보안에 취약한 프로토콜들의 패킷 스니핑등의 보안공격 방지
        - 응용 프로세스중간에 SSH서버와 클라이언트를 두어 암호키를 통한 보안채널 제공
        - 주요기능으로 인증, 암호화, 무결성, 압축, 포트 포워딩, 다중화를 지원

    [SSH 참고자료](https://itwiki.kr/w/SSH)<br>
    [SSH 참고자료2](https://library.gabia.com/contents/infrahosting/9002/)<br>

- 도메인 서비스
    - DNS (Domain Name Services)
        DNS란 우리가 네이버나 구글에 접속할 때 URL에 영문 주소(www.naver.com)를 입력하게 되는데 이때 해당 영문 주소를 IP주소로 변환해주는 것이다. 
        - 호스트 주소를 IP주소로 변환해준다.
        - 트리 구조로 구성 및 내부 서브도메인을 가질수도 있음.
        - 도메인 네임 스페이스 , 네임 서버, 리졸버로 구성되어 있음

    [ DNS 참고자료 ](https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/)

- 기타 서비스
    - DHCP
        네트워크에서 IP 주소 및 관련 구성 정보를 효율적으로 관리하여 네트워크 구성을 단순화하고 자동화하는 데 사용
        - 클라이언트에게 IP 주소를 동적으로 할당하는 기능을 제공

        - 클라이언트에게 네트워크 구성 정보(서브넷 마스크, 기본 게이트웨이, DNS 서버 등)를 제공 및 해당 정보로 네트워크를 구성

        - IP 주소를 효율적으로 관리하여 중복 사용을 방지하고 주소를 재활용 (반환 및 재사용)

        - DHCP 서버 간에 정보를 공유하고 장애 복구를 제공하기 위해 DHCP 리너링을 사용
        이를 통해 DHCP 서버의 가용성을 향상시키고 네트워크 서비스의 지속성을 보장

        - 동적 IP 주소 할당 외에도 필요한 경우 클라이언트에게 정적 IP 주소를 할당

    - NTP(Network Time Protocol): 네트워크 시간 동기화를 위한 프로토콜

    - RTP(Real-time Transport Protocol): 오디오 및 비디오 스트리밍을 위한 프로토콜

### 응용개체 서비스 요소
- UE (User Element) : 응용프로그램이 데이터통신을 수행하기 위해 응용서비스를 이용하는 요소

- CASE(공통 응용 서비스 요소, Common Application Service Element) : 응용 계층 내에서 공통으로 사용되는 서비스 요소
  - 결합 제어 서비스 요소(ACSE)
  - 원격 조작 서비스 요소(ROSE)
  - 고신뢰 전송 서비스 요소(RTSE)
  - 책임, 동시 실행 및 회복 제어(CCR) 서비스 요소

- SASE(특정 응용 서비스 요소, Specific Application Service Element) : 특정 기능에 사용되는 서비스 요소
  - 파일 전송/접근 및 관리(FTAM)
  - 메시지 통신 처리 시스템(MOTID/ MHS)
  - 분산 트랜잭션 처리(DTP)
  - 원격 데이터베이스 접근(RDA) 등

[ 응용 서비스 요소 참고자료 ](https://terms.tta.or.kr/dictionary/dictionaryView.do?subject=%EC%9D%91%EC%9A%A9+%EC%84%9C%EB%B9%84%EC%8A%A4+%EC%9A%94%EC%86%8C)

### 응용계층 역할 정리
사용자와 네트워크 사이의 인터페이스를 제공한다.<br>
응용계층은 사용자에게 네트워크 서비스를 제공하기 위한 응용 프로그램과 상호 작용하고 사용자가 웹 브라우저, 이메일 클라이언트, 파일 전송 프로그램 등을 통해 네트워크를 사용할 수 있도록 한다.<br>
즉 , 사용자 요구를 처리하고, 데이터의 전송 및 수신을 관리하며, 다른 계층과의 상호 작용을 조정하는 역할.<br>
