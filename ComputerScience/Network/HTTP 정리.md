# HTTP 정리

[김영한님의 모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)을 듣고 정리한 내용입니다.

## 인터넷 네트워크란?

HTTP를 알아보기 전에 통신이 어떻게 이루어지는지 간단하게 알아보자.

### 멀리 떨어져있는 기기끼리 어떻게 통신할 수 있을까??

부산에 있는 A씨가 서울에 있는 B씨에게 데이터를 보낸다고 가정하자.<br>
그러면 A씨가 사용하는 컴퓨터에 데이터를 입력하여 B씨의 컴퓨터에 전송하기 위해선 B씨의 컴퓨터를 우선 찾아야 된다.
이때 MAC주소와 IP주소를 사용하게 되고 A씨와 B씨는 물리적으로 연결되어 있는데,
이렇게 먼거리를 통신하려면 중간에 신호를 증폭시켜주는 장치와 도착할 수 있는 최단 경로를 알아내기 위한 장치인 라우터(노드)들을 거치게 되는데 이 중간에 있는 여러 개의 라우터(노드)의 집합을 인터넷이라 부른다.

### MAC과 IP주소란?
- MAC
    - MAC은 기기의 고유주소이다. (거의 유일함)<br>
    - LAN 통신(근거리)에서 MAC주소를 사용한다.<br>
    - 48bit 주소체계 (16진수 12개 and 콜론(`:`)으로 구분 )


- IP주소
    - IP주소는 동적인 IP와 고정IP가 있으며, 사설IP와 공인IP가 구분되어 있다.<br>
    - IPv4 : 32bit 주소체계 (8비트씩 4개 and 옥텟(`.`)으로 구분)
    - IPv6 : 128bit 주소체계 (16진수 4bit 4개의 그룹으로 총 8개 콜론(`:`)으로 구분)
    - 숫자로 구성
        ex) 168.192.10.1 (IPv4)
        ex) 3FFF:1002:FFDD:1258:0000:0000:0000:0000 -> 3FFF:1002:FFDD:1258:: (IPv6)
    - 서브넷마스크 ( 네트워크 주소와 호스트 주소를 나눠주는 역할)

### 공인IP와 사설IP 

- `공인 IP`
    - 인터넷상에서 유일한 값을 가진다.
    - 특정 기업에서 발급한다. (유료)
    - 보안에 각별히 신경써야 한다.

- `사설 IP`
    - 네트워크 상에서 유일한 값을 가진다.<br>
    - 하나의 공인IP를 받아 여러 사설IP를 사용한다.<br>
    - 사설IP는 외부에 노출되지 않고 외부에 데이터를 보낼 시에 NAT을 통해 변환되어 통신한다.

나누는 이유는 다양한 이유가 있지만, 우선 수많은 기기가 각자 고유한 IP를 가진다면 IP개수가 턱없이 부족할 것이다.<br>
사설망에서 데이터를 외부로 보낼때 공인IP를 가지고있는 라우터를 거치게 되는데 이때 사설IP가 공인IP로 바뀌게된다.[Network Acess Translation](https://en.wikipedia.org/wiki/Network_address_translation)<br>

### IP (Internet Protocol)
데이터 단위를 패킷(Packet)이라 부름<br>
패킷은 출발지 , 목적지 , 보낼데이터 등을 담아 보낸다.<br>

요청과 응답시 서로 다른노드를 거쳐 올 경우가 있다.<br>
왜냐하면 중간에 라우터가 데이터를 너무많이 받아서 우회할 경우도 있고,<br>
문제가 발생하여 작동을 안할수도 있기 때문이다.<br>

인터넷 프로토콜은 오로지 목적지를 향해 데이터를 최적의 경로로 송신하는 목적을 가진 프로토콜이다.

### IP 프로토콜의 한계
- 비연결성

    패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송

- 비신뢰성

    중간에 패킷이 사라지거나 패킷이 순서대로 안오는 케이스들에 대해 대처가 불가능

- 프로그램 구분

    같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이라면 이 애플리케이션들을 구분할 수 없음

> 위의 한계점들을 극복하기 위해 TCP/UDP, PORT가 개발됨.

## TCP와 UDP

IP 프로토콜은 신뢰할수 없는 프로토콜이다.<br>
위에 IP프로토콜의 한계에서 적어놧듯이 IP프로토콜은 상대가 받을수있는 상황이 아니라도 데이터를 전송하고,
또 패킷이 중간에 사라지거나 손실되도 대처가 안되며 순서대로 도착할거라는 보장이 없다.<br>
이를 위해 TCP 프로토콜이 존재한다.

### TCP (RFC 793)

- 신뢰성 있는 통신 프로토콜
- 두 프로세스간에 안정적으로 통신이 가능한지 사전에 가상의 연결을 시도 (3way-HandShake)
- Port Number를 통해 대상 식별함.
- 순서 보장 및 흐름제어, 오류제어, 흐름제어 역할을 함

### UDP

- 간단한 기능만을 제공하는데 IP와 유사하다.
- 기본적으로 TCP와 같이 Port번호를 통해 대상을 식별
- 신뢰성 , 순서보장 , X
- 속도가 빠르다.
- 애플리케이션 즉, 상위계층에서 추가작업 해야함.

## PORT 와 Socket

### PORT

TCP와 UDP를 설명하면서 계속 Port를 언급하였는데 Port에 대해 간단하게 설명하겠습니다.
Port는 대상을 식별하기 위한 0~65535 범위의 번호를 가짐.<br>
Port를 통해 대상을 식별함 = 패킷을 구분지어 어느 프로세스로 갈지 정하기 위한 번호<br>
즉, Port는 해당 프로세스로 가기위한 주소라고 볼수 있다.

### SOCKET

TCP/IP 프로토콜 표준에서 Socket은 IP와PORT를 합친것 이다.<br>
고유한 host주소와 프로세스로 가기 위한 주소 PORT를 합치므로 유니크하게 식별할 수 있다.<br>
즉 , 네트워크 상에있는 프로세스 간 통신의 종착점(End Point)이다.

## DNS란?
우리는 네이버나 구글을 들어갈 때 우리가 쓰는 문자를 주소창에 입력하여 들어가게 되는데,<br>
이는 사실 주소를 입력하게 되면 ip로 바뀌어서 접속하게 된다.<br>

> www.naver.com 입력 -> 223.130.195.95:443 반환 -> 네이버 접속

위의 과정을 거치게 되는데, 이 때 영문자로 주소를 입력하면 ip주소로 반환해 주는 것을
`DNS (Domain Name Service)`라고 한다.

- 호스트 주소를 IP주소로 변환해준다.
- 트리 구조로 구성 및 내부 서브도메인을 가질수도 있음.
- 도메인 네임 스페이스 , 네임 서버, 리졸버로 구성되어 있음

## URI?? URL??

### URI란?

`리소스를 식별하기 위한 정보`를 담은 주소
URL 과 URN 등으로 나뉜다.

    Uniform : 리소스 식별하는 통일된 방식
    Resource : 자원, URI로 식별할 수 있는 모든 것(제한 없음)
    Identifier : 다른 항목과 구분하는데 필요한 정보

- URL(Uniform Resource Location)
    - 리소스가 있는 위치(경로)를 지정
    - 프로토콜을 포함
    - 웹 뿐만이 아니라 컴퓨터 네트워크상의 자원을 모두 나타낼 수 있음
        ex ) file:///C:/HTTP/URLTESTFOLDER/ (컴퓨터 네트워크 사으이 자원을 나타냄)
             https://www.google.com/search?q=http&hl=ko (웹 자원)
    - 문법 방식 

        ![image](https://github.com/9ony/9ony/assets/97019540/6a60b924-bd5b-4b48-b1eb-8a82a4f2acd4)

- URN(Uniform Resource name)
    - 리소스에 이름을 부여
    - 프로토콜을 포함하지 않는다.
    - 이름만으로 실제 리소스를 찾을 수 있음
        ex) urn:isbn:8960777331 (어떤 책의 isbn URN)

## HTTP(Hyper Text Transfer Protocol)란?

### HTTP 역사

- HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X
- HTTP/1.0 1996년: 메서드, 헤더 추가
- HTTP/1.1 1997년: 가장 많이 사용 (대부분의 기능이 들어있음)
- RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)
- HTTP/2 2015년: 성능 개선
- HTTP/3 진행중: TCP 대신에 UDP 사용(QUIC), 성능 개선

### HTTP 특징

- 클라이언트/서버 구조
- 무상태 (stateless) 지향
- 비연결성
- HTTP 메세지로 통신
- 단순하고 확장에 용이함

### 클라이언트 서버 구조란?

Request(응답)과 Response(요청) 구조<br>

1. 클라이언트가 요청을 보내면 서버에 응답을 기다리게 됨
2. 서버가 클라이언트가 요청한 데이터를 전송(html,css 등)
3. 클라이언트가 서버의 응답 데이터를 받음

### 상태유지와 무상태 ( Stateful,Stateless )

- 상태유지의 특징
    - 서버측에서 클라이언트의 상태를 기억
    - 클라이언트 측에서 보내는 데이터가 적음
    - 수평확장(Scale-out)이 어려움
        > 새롭게 확장된 서버는 이 정보를 알지 못한다. 즉, 상태정보 공유하는 식으로 확장해야함
    - 빠른 처리 속도
    - 서버측 오류로 강제다운 시 데이터 재전송

- 무상태의 특징
    - 클라이언트 상태를 기억하지 않음
    - 클라이언트 측 전송할 데이터가 많아짐
    - 서버 부하가 적음 (세션유지 필요 X)
    - 수평확장에 용이 (Scale-out)

### Stateless의 한계점

로그인,장바구니,채팅 등 사용자 정보를 저장해야 하는 서비스에서는 Stateless로는 구현하기 힘들거나 비효율적인 문제가 많다.
예를 들어 로그인 후 이용가능한 서비스를 Stateless로 구현했을때 문제점을 보자

1. 사용자정보를 계속 포함해서 요청해야함
2. 이로인한 보안문제 (사용자정보가 노출)
3. 요청시 리소스 증가 (로그인정보 + 다른 기능에 대한 추가 정보 계속해서 중첩)

이런 최소한의 정보들은 Stateful하게 구현해야 하는데,<br>
이때 `Cookie` , `Session` , `Token(jwt)`들을 이용하여 상태유지를 한다.

> 웹 개발 중 Cookie , Session , Token등을 사용하면서 http가 왜 무상태 프로토콜인지 헷갈려 할 수 있는데 (나만 그랬나?)<br>
HTTP Header에 cookie 정보를 담아서 서버의 session 정보와 비교하여 상태를 유지하는 것이다.
Cookie Session등 상태유지를 위한 기술들은 WAS에서 지원하는 기능인 점을 알아둬야 한다.

요약 : HTTP는 기본적으로 무상태 프로토콜이고 상태유지를 위해 Cookie,Session,Token 등을 사용한다.

### HTTP 커넥션 관리

__비연결성(Connectionless)__

HTTP는 기본적으로 비연결성 프로토콜임
비연결성은 클라이언트가 서버에 요청을하면 서버가 해당 요청에 대한 응답을 한후 연결을 종료하는 것이다.

- 연결을 유지를 위한 리소스 확보 (서버 자원 절약)
- 요청과 응답 사이에는 독립성이 유지
- 모든 요청 시 재연결하므로 오버헤드가 발생 (TCP의 3way-handshake)


- 비연결성 문제점
    
    웹페이지는 여러개의 파일로 이루어져 있다.<br>
    ex) html,css,js,이미지 파일등..<br>
    해당 데이터를 전부 비연결적인 특징을 이용하여 클라이언트가 받는다고 가정하면<br>
    html,css,js 파일들을 받을때 마다 각각 연결에 필요한 오버헤드가 추가적으로 발생한다.<br>
    이를 해결하기 위해 지속연결(Persistent Connection)을 사용한다. 

__병렬 연결(Parallel Connection)__

병렬 커넥션은 만약 4번의 요청을 처리한다고 가정하면 첫번째 요청에 대한 응답이 올때까지 두번째 요청이 기다리지 않고
커넥션은 여러개 맺어서 한번에 4개 요청을 보내는 것이다.<br>
즉 , 여러 TCP 커넥션을 통한 HTTP 요청이다.

![image](https://github.com/9ony/9ony/assets/97019540/80d0da29-8abf-4748-a683-6bf6bfdacd90)

- 단일 커넥션의 대역폭 제한과 커넥션이 동작하지 않고 있는 시간을 활용
- 남은 대역폭을 사용한 더 빠른 속도 향상
- 제한된 대역폭 내에서는 각 트랜잭션 처리가 느리기 때문에 항상 빠르지는 않음
- 우선순위 처리 어려움
- 여러 개의 TCP 커넥션이 동시에 열리므로, 네트워크 리소스 및 서버 리소스를 더 많이 사용
- 연결의 설정과 해제는 네트워크 오버헤드와 시간 지연을 초래

__지속연결 (Persistent Connection)__

![image](https://github.com/9ony/9ony/assets/97019540/14030aa5-219c-43ea-abf9-abc193cef968)

위 그림과 같이 많은 데이터를 받을 때 비연결성은 데이터의 개수마다 새로 연결을 맺어야 하는 치명적인 단점이 있는데<br>
HTTP/1.0+ 부터는 오른쪽 그림과 같이 지속연결을 통해 문제를 해결하였다.

- 요청과 응답은 같은 TCP 연결을 통해 처리
- 같은 서버에 있는 파일(html,css,image 등) 및 여러 웹 페이지들을 한번의 TCP 연결을 전송
- HTTP 서버는 일정 기간(타임아웃) 사용되지 않으면 연결을 종료
- HTTP1.1 부터 Keep Alive가 기본값으로 설정되어 있다.

     __Keep Alive__<br>
    HTTP/1.0+에 추가된 기능 기존에 연결된 TCP 연결을 재사용 하는것

    __Keep-Alive 지원 시 응답헤더__<br>
    ![image](https://github.com/9ony/9ony/assets/97019540/d2ebcf67-603d-4fde-903a-481718e3a30c)

    __Keep-Alive 미지원 시 응답헤더__<br>
    ![image](https://github.com/9ony/9ony/assets/97019540/fb9ca316-6d63-4381-9937-ee1c54751a5f)


    그림과 같이 서버에서 keep-alive를 지원한다면 응답헤더 Connection옵션에 keep-alive 정보가 담겨서 온다.<br>
    Keep-Alive 옵션으로 max와 timeout이 있다.<br>
    max는 현재 커넥션에 최대 요청개수로 요청마다 max값이 1씩 줄어든다. 0이되면 커넥션을 끊는다.<br>
    timeout(초단위)은 커넥션 유지 시간이다. 해당시간동안 요청이없다면 커넥션을 끊는다.<br>
    

    __Persistent Connection__<br>
    HTTP/1.1 부터 도입된 개념으로 Keep Alive를 기본적으로 사용하고 여러 개의 요청과 응답을 동일한 연결을 통해 처리

    __Pipelining__<br>
    파이프 라이닝은 여러개의 요청을 보낼때 처음 요청이 응답될 때까지 기다리지 않고 바로 요청을 한꺼번에 보내는 것을 의미한다.<br>
    즉, 여러개의 요청을 한꺼번에 보내서 응답을 받음으로서 대기시간을 줄이는 기술이다.<br>
    
    ✔ 이때 병렬 연결과 헷갈릴수 있는데 병렬연결은 여러 TCP 연결을 통해 동시에 처리하는 것이고 파이프 라이닝은 하나의 TCP 연결의 재사용을 활용한 keep-alive를 전제로 한다.<br>
    
    - 요청을 한꺼번에 보냄
    - `요청이 들어온 순서대로(FIFO) 응답`을 반환
    - `응답 순서를 지키기 위해` 응답 처리를 미루기 때문에 Head Of Line Blocking(HOLB) 문제가 발생
    - 현재 대부분의 브라우저들은 파이프라이닝을 사용하지 못하도록 막아 놓음

HTTP/2.0에서는 위의 HTTP/1.1 버전의 Head Of Line Blocking,헤더압축 등의 문제점들은 개선하였다.

[ HTTP/2.0 관련자료 ](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-20-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0-%EC%9D%B4%EC%A0%9C%EB%8A%94-%ED%99%95%EC%8B%A4%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90#http_1.1_%ED%86%B5%EC%8B%A0_%EA%B3%BC%EC%A0%95)


### HTTP 구조와 메세지

__HTTP 메세지의 구조__<br>
![image](https://github.com/9ony/9ony/assets/97019540/d58f7da1-fd72-4f3b-960a-bc5e5b64de9b)

- 시작 라인
    - 요청
    1. HTTP 메서드 
        - 종류 : GET , POST , PUT , DELETE 등..
        - 서버가 수행 해야할 동작을 지정함.
            GET : 조회 , POST : 요청 데이터 처리  , PUT : 데이터 덮어쓰기 or 없으면 생성 등..
    2. 요청 대상 
        - 경로 (절대 경로 , * , 상대경로)
        - \+ ?쿼리
    3. HTTP 버전
        - HTTP/1.1 , HTTP/2 등..
    
    - 응답
    1. HTTP 버전
        - (요청의 HTTP 버전과 동일)
    2. 상태코드
        - 200,400,500번대 코드가 있음
    3. 이유문구
        - 사람이 이해할 수 있는 짧은 설명
        ex) OK , Created , Not Found
- 헤더
    1. 필드 이름 (대소문자 구분 X)
        - Host,Content-Type 등.. (표준헤더가 엄청 많아서 아래 링크에 잘 정리 되있습니다)
        - HTTP 전송에 필요한 모든 부가정보의 이름
    2. 필드 값 (대소문자 구분 O)
        - 해당 필드 부가정보의 값 
    
    ✔ 헤더는 커스텀 헤더가 작성 가능함 (대신 클라이언트도 해당 헤더를 알아야 됨)
    [ 표준 헤더 종류 ](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers)
- 메세지 바디<br>
    실제 전송할 데이터 <br>
    HTML , JSON , IMAGE , 영상등 Byte로 표현할 수 있는 모든 데이터<br>

[RFC7230 참고](https://datatracker.ietf.org/doc/html/rfc7230#section-3)