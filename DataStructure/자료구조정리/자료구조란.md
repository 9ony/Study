# 자료구조 정리

## 자료구조란?

효율적인 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장을 의미  
데이터를 다루는 구조 그 자체를 뜻하고 구현하는 방식에는 제약이 없습니다.     
자료의 집합을 구조화하고, 데이터를 효율적으로 관리하고 사용하기 위한 다양한 방법을 제공합니다.    

### 자료구조의 중요도

이러한 자료구조가 왜 중요하냐면 자료구조는 구조별 또는 구현하는 방식에 따라 저장된 데이터를 저장(삽입), 조회, 수정, 삭제 , 정렬 등등의 기능을 수행하는 시간(시간 복잡도)이 다릅니다.  
어떠한 상황에 어떤 자료구조를 써야 효율이 좋을지에 알려면 자료구조를 공부해야 하며 어떻게 동작하는지 알 필요가 있습니다.  
이를 위해 상황별로 적합한 자료구조를 선택 하기 위해 복습 겸 정리하게 되었습니다!!    

## 자료구조의 분류

#### 단순 구조

단순구조는 자료형을 뜻함  
정수(Integer), 실수(float,double), 문자(Character), 문자열(String) , 참/거짓(boolean) 등이 해당됩니다.  
 
#### 선형 구조

자료들 간의 앞뒤 관계가 1:1인 선형 관계를 의미한다.  

- 배열(Array) : 가장 기본적인 자료구조  
배열은 인덱스와 인덱스에 해당하는 데이터들로 이루어져 있으며, 생성 시 설정된 크기가 고정되는게 특징이다.   

- 동적배열(DynamicArray) : 데이터 삽입,삭제 등이 가능하고 크기가 동적으로 변하는 자료구조 

- 스택(Stack) : LIFO(Last In First Out)의 자료구조  

- 큐(Queue) : FIFO(First In First Out)의 자료구조  

- 덱(Deque) : 양쪽에서 모두 삽입/인출이 가능한 자료구조  

- 연결 리스트(Linked List) : 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조  
인덱스나 위치와 같은 데이터의 물리적 배치를 사용하지 않고, 다음 노드 연결에 대한 포인터 또는 주소를 사용하는 것이 특징이다.  


#### 비선형 구조

- 트리(Tree) : 부모 노드 밑에 여러 자식 노드가 연결되는 구조로, 자식 노드가 부모가 되어 다시 각각의 자식 노드가 연결되는 재귀적인 형태의 자료구조  

- 그래프(Graph) : 노드(Node)/정점(Vertex)과 이들 사이를 연결하는 엣지(Edge)로 구성된 자료구조를 의미한다.  
그래프는 방향이 있을 수도 없을 수도 있으며 다양한 구조로 설계된다.  

## 자료구조별 간단 정리

## 선형 자료구조

선형 자료구조인 배열,연결리스트,스택 등의 기본적인 특징들을 정리해보았습니다.

### 배열(Array)

배열은 정적배열과 동적배열을 나누어서 정리하겠습니다.  

#### 정적 배열 (Array)

배열(Array)은 프로그래밍에서 가장 기본적이고 중요한 자료구조 중 하나로, 동일한 데이터 타입의 요소들을 순차적으로 저장하는 자료구조입니다.  
배열은 메모리 내에 연속적으로 할당되고 각 요소는 인덱스(index)를 통해 접근합니다.  

- 특징  
    
    - __고정 크기__  
    배열은 생성할 때 크기가 고정되며, 크기를 동적으로 변경할 수 없습니다.  
    크기를 변경하려면 새로운 배열을 생성하고 데이터를 복사해야 합니다.  
    고정 크기로 인해 만약 생성된 배열의 크기만큼 공간을 활용하지 않는다면 메모리 낭비가 발생 합니다.  

    - __동일한 데이터 타입__  
    배열 내의 모든 요소는 동일한 데이터 타입을 가져야 합니다.  

    - __인덱스를 사용한 데이터 접근__  
    배열 요소에 접근하려면 해당 요소의 인덱스를 사용합니다.  
    인덱스를 통해 접근하여 빠른 데이터 접근이 가능합니다.  

    - __메모리 연속성__   
    배열은 메모리 내에서 연속적으로 할당됩니다.  
    요소값 조회 = 배열의 메모리주소 + (데이터 타입에 대한 크기 * 인덱스)  
    ex)  
    ```java
    //{0, 1, 2, 3, 4}의 값을 가지는 배열A가 있는데, int는 4byte크기고 해당 배열의 주소가 0x20이라 하자.  
    int[] A = new int[]{0,1,2,3,4};
    // A의 메모리주소가 0x20
    // 0번째 인덱스 메모리주소는 0x20 + (4byte(int) * 0(index)) = 0x20
    // 1번째 인덱스 메모리주소는 0x20 + (4byte(int) * 1(index)) = 0x24
    //...
    ```
    데이터를 순차적으로 저장하기 때문에 인덱스를 통해서 빠르게 데이터 접근이 가능해집니다.  

- 시간복잡도  
    - 접근: O(1)  
    - 수정: O(1)  
    - 추가 삭제: O(n) (새로운 배열을 만들어 복사해야 함)  
        ✔ 단, 정적배열은 크기가 정해져있으므로 데이터의 추가 삭제가 필요하면 동적배열을 사용하는게 일반적이다.  
    - 검색: O(n)

이러한 정적 배열은 다른 자료구조에 기반이 되는 자료구조입니다.  

#### 동적 배열 (Dynamic Array)

동적배열은 정적배열이 크기를 늘리거나 줄일때 필요한 동작들을 지원해주는 자료구조라 생각하면 됩니다.  

- 특징 
    - __내부적으로 크기는 정적이다__   
        이 말은 동적배열도 처음 생성할때 크기를 정적으로 설정합니다.  
        자바의 경우는 크기 설정을 안 할 경우 10.  
        초기화된 동적배열에 값을 2개 추가했을 경우 외부적인 크기(size)는 2로 나오지만 아직 8개의 공간에 데이터가 할당되어 있지 않을 뿐 내부 메모리의 크기(capacity)는 10이라는 의미  
    
    - __동일한 데이터타입+참조타입만 할당가능__   
        
       ✔ 왜 참조타입만 가능할까?  
    
    그 이유는 동적배열도 내부적인 크기가 초과될때 크기를 늘린 새로운 배열을 만들어서 기존것을 복사하게 되는데 이때 참조 타입을 저장하는 경우에는 객체 자체가 아닌 참조주소만을 복사하므로 데이터의 크기가 큰 경우에도 빠르게 복사할 수 있습니다.  
    객체 데이터는 힙(heap) 메모리에 남아 있고, 새로운 배열은 새로운 레퍼런스를 가지고 기존 객체를 참조하므로 메모리 효율적으로 작동할 수 있습니다.  
    
    > 이외에 인덱스를 사용하는 것과 메모리 연속성 같은 특징은 정적배열과 같습니다.  
    
- 시간 복잡도
    - 접근(access): O(1) (index를 사용하여 빠름)  
    - 수정: O(1)  
    - 삽입(add): O(1)  
        요소를 추가 할 내부 용량(capacity)이 남아있다면 size(요소를 포함한 개수)에 해당하는 인덱스에 값을 `=` 으로 할당하는 것 
    - 추가(insert),삭제 : O(n)  
        내부 요소들이 쉬프트되므로 O(n) (값들이 밀리거나 당겨짐)    
    - 검색: O(n)  

    > 자바에서 삽입은 add(index,element) 메서드다.  
    add(element)만 한다면 추가로 O(1)인데, 이때 내부 capacity가 size와 같다면 배열의 크기를 늘리면서 O(n)이 된다.  

#### 정적 배열과 동적 배열 비교

    1. 정적배열은 원시타입도 넣을 수 있다. 동적배열은 참조타입만 가능.  

    2. 정적배열 동적배열 둘다 물리적메모리가 연속된다.  

    3. 정적배열의 고정된 크기를 가지지만, 동적배열은 더 크거나 작은 배열을 새로 생성해 복사하여 크기를 조정한다.  

    4. 둘 다 사용하지 않는 공간이 있을 수 있으므로 메모리 낭비가 있을 수 있다.  

### 연결 리스트(Linked List)  

연결 리스트(Linked List)는 데이터 요소가 노드(Node)로 구성되어 선형적으로 연결된 자료구조입니다. 각 노드는 데이터 요소와 다음 노드를 가리키는 포인터(또는 링크)로 구성되어 있습니다.  

- 특징
    - 동적 크기
        연결 리스트는 동적으로 크기를 조정할 수 있습니다.  
        새로운 노드를 추가하거나 기존 노드를 제거할 때마다 크기가 조절됩니다. 

    - 메모리가 연속적이지 않다  
        배열과는 다르게 객체(노드)가 객체(다음노드)를 가르키는 형태입니다.  
        =>  물리적으로 연속된 메모리 위치에 저장하지 않음  
        즉 메모리가 연속적이지 않고, 현재 객체가 다음 객체를 가르키면서 선형적인 구조를 띕니다.  
        메모리가 연속직이지 않기 때문에 인덱스를 사용하지 않습니다.  
        (논리적 인덱스를 가진다)
    
    - 접근이 느리다.  
        논리적 인덱스로 객체의 물리주소를 알 수 없기 때문에 순회하여 찾아야 하므로 느립니다.  
    
    - 메모리 낭비가 적을 수 있다.  
        배열이나 동적배열은 결국 메모리가 연속적이기 때문에 크기를 늘린 배열을 복사하면서 크기를 점점 늘려갔다.  
        그리고 사용하지 않는 메모리 공간의 낭비가 발생한다.  
        하지만 연결 리스트는 객체를 생성하고 연결만 하면 된다.  
        즉 생성 시 마다 연결만 해주면 됨.  
    
- 시간 복잡도
    - 삽입,추가,삭제 : O(1)  
    - 접근,검색 : O(n)  


#### ✔ ArrayList와 LinkedList 언제 써야 할까!?

- Linked List가 더 유리한 경우

    O(1)의 삽입/삭제가 자주 필요한 경우
    조회 작업을 많이 하지 않는 경우

- ArrayList가 더 유리한 경우
    index를 활용해 배열의 요소를 빠르게 접근 가능  
    즉, 조회 작업을 자주 해야 하는 경우  

### 스택 (Stack)  

스택은 선입후출or후입선출 자료구조입니다.  
제일먼저 추가된 데이터가 제일 마지막으로 빠져나가는 구조  
스택안에 데이터가 접시처럼 쌓인다고 생각하면 됩니다.  

- 특징
    - __선입후출 자료구조로 FILO (First In Last Out)__  
        가장 먼저 입력된 데이터가 가장 나중에 출력(삭제)된다.    
        == 가장 나중에 입력된 데이터가 가장 빨리 출력된다.  

- 시간 복잡도
    - 삽입(push) : O(1)
    - 삭제(pop) : O(1)
    - 접근,검색 : O(n)
    - 읽기(peek) : O(1) (가장 최근에 삽인한 요소를 조회)


### 큐 (Queue)

큐는 스택과 반대로 선입선출 자료구조입니다.  
제일먼저 추가된 데이터가 제일 빨리 빠져나가는 구조   

비유하자면 정수기 옆 종이컵을 꺼내 쓰는것(?)처럼      
종이컵을 넣을때 먼저 넣은게 제일 빨리 써지는것과 같은 방식입니다.  

- 특징  
    - __선입선출 자료구조 FIFO (First In First Out)__  
        가장 먼저 입력된 데이터가 가장 빨리 출력(삭제)된다.  
    
    - __스택과 차이__
        선입선출이라는 점도 차이가 있지만,  
        스택은 데이터가 들어가는 인덱스와 나가는 인덱스가 같다.  
        하지만 큐는 먼저들어간 데이터가 제일 나가고, 데이터가 큐에 들어갈 때는 다른 인덱스이다.  
        즉, 빠져나갈 인덱스와 데이터가 들어올 인덱스 2개가 필요하다.  
        보통 front(앞), rear(뒤) 이라 한다.  

- 시간 복잡도
    - 삽입(Enqueue) : O(1)
    - 삭제(Dequeue) : O(1)
    - 접근,검색 : O(n)
    - 읽기(peek) : O(1) (맨 앞에 있는 요소를 조회)

### 덱 (Deque)

스택과 큐를 짬뽕시킨 자료구조라 보면 됩니다.  
=> Deque는 Double-Ended Queue의 줄임말
데이터를 추가하는 부분에서 데이터를 뽑아낼수도 있는 구조입니다.

- 특징
    - __양쪽 끝에서 요소를 삽입 및 삭제할 수 있는 자료구조__  
        front(앞),rear(뒤) 양쪽에서 삽입 가능  
        양쪽 끝에 인덱스(front,rear)를 사용하여 요소에 접근한다.  
        만약 삭제가 일어나면 해당 부분의 front 또는 rear의 인덱스가 다음요소로 이동함.  
        값이 인덱스로 맞춰지는게 아니라 인덱스가 다음요소로 이동된다고 보면됨.  

    - __스택과 큐의 기능을 모두 제공__  

- 시간 복잡도:
    - 삽입 및 삭제: O(1) (데크의 양쪽 끝에서 삽입 및 삭제 가능)  
    - 접근,검색: O(n)  
    - 읽기(peek) : O(1) (front 또는 rear에 있는 요소를 조회)  

### 스택,큐,덱 참고

스택,큐,덱은 배열로도 구현이 가능하지만 연결리스트를 통해 구현하는 것이 일반적이다.  
왜냐하면 배열은 일반적으로 메모리 사용이 많이되며 각각 head나 tail같은 논리적 인덱스(포인터)가 존재한다.  
이는 연결리스트와 유사한 구조를 띄는데, 연결리스트도 head가 첫번째 노드를 가르키며 원형 연결리스트의 경우 tail이라는 마지막 부분이 head를 가르켜서 순환하는 구조이다.  
즉 단일 연결리스트로 스택 구조를 구현하기 용이하며, 원형 연결리스트로 큐를 구현하기가 적합한데 이를 추후 예제를 통해 비교해볼 예정이다.  

<hr>

## 비선형 자료구조

비선형 자료구조인 트리,그래프 등의 기본적인 특징들을 정리해보았습니다.   
비선형 자료구조는 데이터의 표현방식에 중점을 둔 자료구조 입니다.  

### 트리(Tree) 

트리는 정점(Node)과 선분(Branch)을 이용하여 `사이클로 이루어 지지 않도록 구성된 그래프`의 특수한 형태이다.  
`계층 모델로 노드가 N개인 트리는 항상 N-1개의 가지를 갖는다.`  
루트에서 특정 노드로 가는 경로는 유일하며, 트리의 순회는 전위,중위,후위로 이루어진다.  

__트리 그림 예시__  

![image](https://github.com/9ony/9ony/assets/97019540/d530e3e7-95e1-4f2e-a3eb-6582db358383)


- 노드(Node) : 트리의 기본 요소. 자료 항목과 다른 항목에 대한 가지(Branch)를 합친 것이다. 

- 가지(Branch, Edge) : 노드와 노드를 연결하는 간선

- Root : 트리의 맨 위에 있는 노드(A)이다. 

- 차수(Degree) : 각 노드에서 뻗어나온 가지의 수이다. (A는 차수가 2)  

- 트리의 차수 : 노드들의 차수 중에서 가장 많은 수를 의미한다.

- 단말 노드(Terminal Node or Leaf Node) : 자식이 하나도 없는 노드(D,E,G,I,J)이다.  

- 비단말 노드(Non-Terminal Node) : 자식이 하나라도 있는 노드(A,B,C,F,H)이다.  

- 자식노드(Children Node) : 어떤 노드에 연결된 다음 레벨의 노드(C는 B의 자식)들을 의미한다.  

- 부모노드(Parent Node) : 어떤 노드에 연결된 이전 레벨의 노드(C는 B의 부모)이다.  

- 형제노드(Sibling) : 동일한 부모를 갖는 노드들을 의미(C는 F와 형제)한다.  

- Level : 루트 노드의 레벨을 0으로 가정하면 자식은 L+1로 1이다.  

- 깊이(Depth, Height) : 어떤 트리에서 노드가 가질 수 있는 최대의 레벨을 의미한다.(마지막 자식노드의 레벨 3)  


#### 트리의 종류  

- 이진 트리(Binary Tree)

    각 노드가 최대 두 개의 자식을 갖는 트리이다. 모든 트리가 이진 트리는 아니다.  

    이진 트리의 순회는 중위 순회(left -> 현재 -> right), 전위 순회(현재 -> left -> right), 후위 순회(left -> right -> 현재)가 있다.  

    이진 탐색 트리는, 모든 노드가 `모든 왼쪽 자식들 <= 루트 노드 <= 모든 오른쪽 자식들`의 특정 순서를 따르는 이진 트리이다.   
 
- 완전 이진트리(Complete BT)

    마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있는 트리이다.  

- 균형 이진트리(Full Binary Tree)

    모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리이다.(1이 있다면 균형트리가 아니다.)  

- 포화 이진트리(Perfect Binary Tree)

    균형 이진트리이면서 완전 이진트리로, 모든 단말노드는 같은 높이에 있어야 하며, 모든 내부 노드가 두 개의 자식노드를 갖는다.  

- 균형 트리(B-Tree)

    균형트리로는 레드블랙트리, AVL트리가 등이 있으며, 시간 복잡도 O(logN)에 삽입, 찾기 등을 무리없이 가능한 균형 잡힌 트리이다.  


트리의 쓰임새는 다양한데, 정렬에서 Heap정렬 등에 쓰이는 최소 힙(부모노드 <= 자식노드, 오름차순)과 최대 힙(부모노드 >= 자식노드, 내림차순)또한 완전 트리구조로 되어 있다.  
또 이진탐색트리도 존재하는데 , 추후 구현을 통해 확인해보자.   

> 위에서도 설명했듯이 트리는 그래프의 특수한 형태이며, 부모-자식 관계가 존재하고, 계층적인 구조로 방향이 존재하며 비순환 구조이다. 

------

### 그래프

그래프는 정점(Vertex)과 그 사이를 잇는 간선(Edge)로 이루어져있다.  
G = (V, E)는 정점의 집합 V와 간선의 집합 E라고 할 때, 그래프 G는 V와 E의 집합 (V, E)라는 뜻이다.  
V(G)는 그래프 G의 정점 집합이고, E(G)는 그래프 G의 간선 집합이다. 간선은 (정점 v, 정점 w)형식이다.  

#### __그래프 용어__  

    - 정점(Vertex): 노드(node)  
    - 간선(Edge): 정점을 연결하는 선  
    - 차수(분지수, degree): `무방향 그래프`에서 하나의 `정점에 붙어있는 간선 개수`  
    - 진출 차수(내향 분지수, in-degree): 방향 그래프에서 `들어오는 간선` 개수  
    - 진입 차수(외향 분지수, out-degree): 방향 그래프에서 `나가는 간선` 개수  
    - 인접(adjacent)과 부속(incident) : 
        인접은 노드사이에 간선이 있음을 의미함.  
        부속은 간선이 연결된 노드에 부속되어 있다고 의미함.  
    - 경로(path): 출발지에서 목적지로 가는 순서
    - 단순 경로(simple path): 경로 중 반복되는 정점이 없음, 한붓그리기처럼 같은 간선 지나지 않음
    - 사이클(cycle): 단순 경로의 출발지와 목적지가 같은 경우


#### 그래프의 종류  

- 무방향 그래프(Undirected Graph)   

    ![image](https://github.com/9ony/9ony/assets/97019540/e745e297-fb04-4897-b25f-a29ec5eb30e3)  

    두 정점을 연결하는 간선에 방향이 없는 그래프 ( 양 방향으로 연결)  
    V(G) = {1, 2, 3, 4}  
    E(G) = {(1, 2), (1, 4), (1, 3), (2, 3), (2, 4) , (3, 5)} 

    `V(G) 1`의 차수는 3, 인접 노드는 2,4,3 이다.  
    `E(G) {1,2}`의 간선은 `V(G) 1`과 `V(G) 1`에 부속되어 있다.  

- 방향 그래프(Directed Graph)   

    ![image](https://github.com/9ony/9ony/assets/97019540/ecde0c1b-48d1-4bda-b9f3-eaa938d91c7c)  

    두 정점을 연결하는 간선에 방향이 있는 그래프 ( 한쪽 방향으로 연결 )  
    V(G) = {1, 2, 3, 4}  
    E(G) = {(1, 2), (1, 4), (2, 3), (3, 1), (4, 2), (5, 3)}  

    V(G) 1의 `진출 차수는 2` , `집입 차수는 1` 이다.  
    V(G) 1의 인접 노드는 2와 4라 할 수 있다.  
    => 단, 2의 방향이 1로 가르키는 간선이 없으므로 인접노드는 1이 아니다.  

    > (Vi,Vj) 와 (Vj,Vi)는 방향 그래프에서는 다르고 무방향에서는 같은 간선을 의미한다. 
    방향 그래프는 화살표가 시작한쪽이 Vi 위치에 이어진 쪽이 Vj위치에 속한다.    


- 가중치 그래프(Weighted Graph)   

    ![image](https://github.com/9ony/9ony/assets/97019540/1316496b-1fcd-411e-ae7c-c726e9edb6ee)  

    두 정점을 연결하는 간선에 가중치가 존재한다.  
    가중치란? 노드에서 노드까지 간선을 타고 이동할때 비용  


- 완전 그래프(Complete Graph)  

    ![image](https://github.com/9ony/9ony/assets/97019540/56f8fb49-02e6-4567-9455-c6a382b704d9)  

    모든 정점 간에 간선이 존재하는 그래프이다.
    정점의 수가 n일 때 전체 간선의 수는 n * (n-1) / 2 가 된다.
    n=5이며 간선의 수는 (5*4)/2=10 이다.


### 자료구조 별 시간 복잡도

![image](https://github.com/9ony/9ony/assets/97019540/d7f83ad6-c5d9-4601-98bd-e1d64c08dfdd)
