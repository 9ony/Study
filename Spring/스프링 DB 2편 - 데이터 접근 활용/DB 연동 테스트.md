# DB연동 시 테스트

실제 데이터베이스 연동 후에 테스트코드 작성할 시 주의할 점과 설정 방법을 알아보자.

## 데이터베이스 연동 

ItemRepositoryTest을 테스트해보자.

### properties 설정

실제 구동하는 Application과 테스트 설정파일이 따로 분리가 되있다.  
> src/main/.../application.properties  
  src/test/.../application.properties  
  분리되어 있음

- application.prperties (src/test)

    ```properties
    spring.datasource.url=jdbc:h2:tcp://localhost/~/test
    spring.datasource.username=sa
    spring.datasource.password=

    spring.profiles.active=test

    logging.level.org.springframework.jdbc=debug
    ```

### ItemRepositoryTest.class 테스트

테스트 코드 작동 시 어떤 문제가 발생할지 코드로 알아보자.  

- ItemRepositoryTest

    ```java
    @SpringBootTest
    class ItemRepositoryTest {
    }

    @Import(JdbcTemplateV3Config.class)
    @SpringBootApplication(scanBasePackages = "hello.itemservice.web")
    //컴포넌트 스캔 경로를 hello.itemservice.web하위로 지정(컨트롤러) 이외 수동등록
    public class ItemServiceApplication {
    }
    ```
    @SpringBootTest는 @SpringBootApplication를 설정해서 사용함  
    즉, itemRepository는 JdbcTemplateV3를 사용  

- test()
    itemName과 maxPrice를 인자로 받아서 ItemSearchCond 생성
    테스트로 들어온 items들과 데이터베이스 내에 findAll()를 통해 ItemSearchCond로 검색한 결과가 같은지 테스트
    ```java
    void test(String itemName, Integer maxPrice, Item... items) {
        List<Item> result = itemRepository.findAll(new ItemSearchCond(itemName, maxPrice));
        assertThat(result).containsExactly(items);
    }
    ```

- findItems()
    ```java
    @Test
    void findItems() {
        //given
        Item item1 = new Item("itemA-1", 10000, 10);
        Item item2 = new Item("itemA-2", 20000, 20);
        Item item3 = new Item("itemB-1", 30000, 30);
        itemRepository.save(item1);
        itemRepository.save(item2);
        itemRepository.save(item3);
        //실패
        test(null, null, item1, item2, item3);
        test("", null, item1, item2, item3);
        //...
    }
    ```

실패하는 이유는 당연한다.  
왜냐하면 현재 로컬에서 작동시킨 데이터베이스로 테스트를 돌렸기 때문에 데이터가 쌓여있다.  

✔ 즉, 테스트를 진행하기 위해서 테스트용 데이터베이스를 분리해주어야 한다.  

## 데이터베이스 분리

테스트용 db 계정을 새로 만들자.  
1\. H2 재부팅  
2\. jdbc:h2:~/testcase 생성 (최초1회 시 생성됨)   
    ✔ ~/컴퓨터명/testcase.mv.db 파일 확인  
3\. jdbc:h2:tcp://localhost/~/testcase 접속

![image](https://github.com/9ony/9ony/assets/97019540/ef83aff0-1baf-45ef-ae88-0e839de674c9)

- src/test/~/application.properties 수정  

    ```properties
    #spring.datasource.url=jdbc:h2:tcp://localhost/~/test 주석처리 or 삭제
    #테스트 서버
    spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase 
    ```

- testcase계정에 item 테이블 생성

    ```sql
    create table item
    (
        id bigint generated by default as identity,
        item_name varchar(10),
        price integer,
        quantity integer,
        primary key (id)
    );
    ```

### 테스트 재진행 (실패)

__❗❗ 결론부터 첫번째 테스트는 통과하지만 재진행 할 시에 실패하게 된다.__  

이유는 간단하다 첫 테스트에는 통과하지만 다시 데이터가 쌓였기 때문이다.  
그러면 데이터를 다시 지워야할까?  
```java
@AfterEach
void afterEach() {
    String deletesql = "delete from Item";
    jdbcTemplate.execute(sql);
}
//and
void test1(){
    //테스트 로직
    String deletesql = "delete from Item";
    jdbcTemplate.execute(sql);
}
```
위 코드 처럼 테스트 진행 후에 데이터를 지워도되지만 우리는 데이터를 롤백하는게 더 합리적이다.  
왜냐하면 테스트가 끝날때마다 해당 delete문을 수행하다가 중간에 예외가 터진다면 해당 delete문이 수행이 안될수도 있고,  
애초에 기존에 쌓아둔 데이터로 테스트를 진행하는 경우도 많기 때문이다.  
즉, 테스트는 반복해서 실행할 수 있어야 한다.

### 테스트 데이터베이스 연동 시 원칙

각각의 테스트가 끝날 떄 마다 해당 테스트에서 추가한 데이터를 롤백해주어야 한다.  
다른 테스트와 격리가 되어야 한다.  
테스트는 반복되서 수행할 수 있어야 한다.  

## 데이터 롤백

트랜잭션 롤백 전략을 사용하여 테스트를 반복실행할 수 있게하자.  

> 트랜잭션 시작 -> 테스트 -> 트랜잭션 종료 ->  
트랜잭션시작 -> 또 다른 테스트 ->트랜잭션 종료 ...  

이렇게 각각의 테스트마다 트랜잭션을 시작하고 롤백해주면 된다.  
각각의 테스트 전 후에 트랜잭션 처리를 해주기 위해 `@BeforeEach`와 `@AfterEach`를 이용하자.  

### 테스트 - 트랜잭션 롤백 활용

- ItemRepositoryTest2
    ```java
    @SpringBootTest
    class ItemRepositoryTest2 {

        @Autowired
        ItemRepository itemRepository;
        @Autowired
        JdbcTemplate jdbcTemplate;
        //트랜잭션 매니저 주입
        @Autowired
        PlatformTransactionManager transactionManager;

        TransactionStatus status;

        @BeforeEach
        void beforeEach() {
            // 트랜잭션 시작
            status = transactionManager.getTransaction(new DefaultTransactionDefinition());
            log.info("트랜잭션 시작 = {}",status);
        }

        @AfterEach
        void afterEach() {
            //MemoryItemRepository일 경우 사용
            if (itemRepository instanceof MemoryItemRepository) {
                ((MemoryItemRepository) itemRepository).clearStore();
            }/*else{
                String sql = "delete from Item";
                jdbcTemplate.execute(sql);
            }*/
            //트랜잭션 롤백
            transactionManager.rollback(status);
            log.info("트랜잭션 롤백 = {}",status);
        }
    //...테스트 동일
    }
    ```

전체 테스트를 실행해보자.  
각각의 테스트 전후마다 트랜잭션이 시작되고 끝난 후 롤백이 되는것을 볼 수 있다.  

- ItemRepositoryTest3
    ```java
    @Transactional
    @SpringBootTest
    class ItemRepositoryTest3 {
        /*@Autowired
        PlatformTransactionManager transactionManager;

        TransactionStatus status;

        @BeforeEach
        void beforeEach() {
            // 트랜잭션 시작
            status = transactionManager.getTransaction(new DefaultTransactionDefinition());
            log.info("트랜잭션 시작 = {}",status);
        } 삭제! */
        @AfterEach
        void afterEach() {
            //MemoryItemRepository일 경우 사용
            if (itemRepository instanceof MemoryItemRepository) {
                ((MemoryItemRepository) itemRepository).clearStore();
            }/*else{
                String sql = "delete from Item";
                jdbcTemplate.execute(sql);
            }*/
            //트랜잭션 롤백
            /*transactionManager.rollback(status);
            log.info("트랜잭션 롤백 = {}",status); 삭제 */
        }

        //이외 테스트 메서드
    }
    ```

    @Trasactional을 이용한 간단한 방법이다.  
    @Test에서 @Transactional을 이용하면 마지막에 트랜잭션이 커밋되지않고 롤백하는 동작을 취한다.
    ✔ 참고로 메서드단위로 필요한 부분에만 @Transactional을 걸어도 종료되지않고 트랜잭션 롤백으로 동작한다.    
    
이렇게 트랜잭션 매니저나 @Transactional을 이용하여 테스트 전후에 트랜잭션 시작후 롤백을 통해 DB의 일관성을 유지 시킬 수 있었다.  
만약 테스트 도중 DB연결이 끊어졌을 경우에도 커밋이 되지않은 상태이고 기본적으로 중간에 통신이 끊기면 데이터베이스는 자동으로 롤백처리한다.  


### 참고

- __@Commit__    
    
    만약 테스트를 커밋해서 데이터가 저장되는지 확인하고 싶으면 @Commit을 추가해주자
    트랜잭션을 롤백 대신 커밋시켜준다.  
    ```java
    @Commit
    @Test
    void findItems() {
        //테스트로직
    }
    ```

    __데이터베이스 저장된 결과__   
    ![image](https://github.com/9ony/9ony/assets/97019540/43a3827a-a1ce-44f2-bab9-bea44fa8c4d0)

@BeforeEach와 @AfterEach는 테스트가 수행시작하기 전후에 실행된다.  
만약 @Transcational이 붙은 테스트에 사전작업과 후처리를 위해 @BeforeEach와 @AfterEach도 썻다면 어떤 흐름을 가질까?  

> 트랜잭션 시작 -> @BeforeEach -> 테스트수행 -> @AfterEach -> 트랜잭션 롤백  

이런 구조로 동작한다.  

## 임베디드 모드 DB
스프링은 임베디드 모드의 데이터베이스( H2, HSQL, Derby)를 지원한다.  
테스트 데이터베이스를 직접 계정을 생성해서 운용하는 것보다 스프링 임베디드 DB를 사용하는게 더 유용할 때가 있는데,    
어떻게 사용하는지 코드로 알아보자.  


### 임베디드 모드 설정

- ItemServiceApplication.class 추가
    ```java
    /**
	 * 임베디드 DB 설정
	 * 프로필이 "test"인 경우만 동작
	 * @return
	 */
	@Bean
	@Profile("test")
	public DataSource dataSource() {
		log.info("메모리 데이터베이스 초기화");
		DriverManagerDataSource dataSource = new DriverManagerDataSource();
		//h2 드라이버 사용
		dataSource.setDriverClassName("org.h2.Driver");
		//mem:db : 메모리 모드(임베디드 모드)
		//DB_CLOSE_DELAY=-1 : jvm 동작중에는 인메모리 데이터베이스의 내용을 유지
		dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
		dataSource.setUsername("sa");
		dataSource.setPassword("");
		return dataSource;
	}
    ```
    > src/test/~/application.properties에 `spring.profiles.active=test` 를 확인하자. 

### 임베디드 DB 스키마와 데이터 초기화

- 인메모리 DB 스키마 작성
    application.properties 추가  
    ```properties

    #테스트 db
    #spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase
    #spring.datasource.username=sa
    #spring.datasource.password=
    ############주석처리 해주자##########################

    #임베디드 DB 설정
    ### Profile("test") DataSource() 사용
    spring.profiles.active=test

    ### schema.sql 경로 변경 (prefix = optional 일시에 파일이 있을때만 실행)
    # 기본경로 optional:classpath*:schema.sql
    #spring.sql.init.schema-locations=optional:classpath*:CreateItemTableSchema.sql

    ### data.sql 경로 변경
    # 기본경로 optional:classpath*:data.sql
    #spring.sql.init.data-locations=optional:classpath*:ItemData.sql
    ```
    
    스키마 스크립트의 기본경로는 ~/src/test/resources/schema.sql 이다.  
    spring.sql.init.schema-locations=경로 를 를해 스크립트 경로를설정할 수 있다.  

- resources/schema.sql
    ```sql
    drop table if exists item CASCADE;
    create table item
    (
        id bigint generated by default as identity,
        item_name varchar(10),
        price integer,
        quantity integer,
        primary key (id)
    );
    ```

- resources/data.sql
    ```sql
    /*
    insert into item(item_name,price,quantity) values('init1',10000,10);
    insert into item(item_name,price,quantity) values('init2',15000,10);
    insert into item(item_name,price,quantity) values('init3',20000,10);
    */
    ```

기존에 testcase를 생성해서 해당 스키마에서 작업을 하였는데 임베디드DB를 사용할 것이기 때문에 주석처리를 반드시 해주자.  

`src/test/resources/`에 schema.sql과 data.sql을 작성하면   
테스트진행 시에 Item Table이 임베디드DB에 생성되고 데이터도 추가된 상태로 시작한다.  
해당 경로와 파일명을 변경하고 싶다면 위 예제의 주석처리된 부분을 참고하자.  
❗ 단, 현재 테스트 진행을 위해 data.sql은 작성하지 않거나 주석처리 해주어야 한다.  

### 결과

![image](https://github.com/9ony/9ony/assets/97019540/454d27a8-fe35-46c8-9ddf-4ac8682427d8)

테스트가 모두 잘 통과하고 임베디드 DB의 Item 테이블의 저장된 데이터도 조회가 되는 것을 볼 수 있다.  
임베디드 DB는 해당 테스트가 끝나고 JVM이 내려가면 해당 임베디드DB는 삭제된다.(JVM메모리 내에서 동작하기 때문)  
임베디드 DB를 통해 테스트를 반복 수행하더라도 계속 통과되는 것을 볼 수 있다.   

단위테스트 시에 임베디드 DB를 사용을 많이 한다고 한다.  

### 스프링 부트와 임베디드 모드

스프링 부트는 임베디드 모드 DB를 기본적으로 지원한다.  
직접 설정했던 데이터소스를 전부 다 주석처리하거나 삭제해주자.  
스프링 부트는 DB에 대한 별다른 설정이 없으면 임베디드 DB를 사용한다  

- application.properties (test 폴더 하위)
    ```properties
    spring.profiles.active=test << 주석처리
    ```
이렇게 설정함으로써 DataSource에 대한 정보가 사라졌다.  
테스트를 실행해보면 테스트가 정상적으로 수행되는 것을 볼 수 있다.  

__결과__  

![image](https://github.com/9ony/9ony/assets/97019540/c8dfd8fc-55ad-457f-9b11-501b9586bae3)

마킹된 부분을 보면 뒤에 임의의 문자들이 붙는다.  
여러 데이터소스가 사용될 때 같은 데이터베이스를 사용하면서 발생하는 충돌을 방지하기 위함이다.  

application.properties 설정 파일에  
```properites
spring.datasource.generate-unique-name=false
```
해당 설정을 해주면 기본값인 jdbc:h2:mem:testdb로 고정된다