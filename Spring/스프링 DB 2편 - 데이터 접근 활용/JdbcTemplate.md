# JDBCTemplate

## JDBC템플릿 이란?
JDBC 템플릿을 사용하면 아래와 같은 jdbc기술 사용시 반복코드 문제들을 해결할 수 있다.  
\- 커넥션 조회, 커넥션 동기화  
\- PreparedStatement 생성 및 파라미터 바인딩  
\- 쿼리 실행  
\- 결과 바인딩  
\- 예외 발생시 스프링 예외 변환기 실행  
\- 리소스 종료  

❗ 단, jdbc템플릿으로 동적 SQL문은 해결하기 어려움.

- jdbc 설정  
    JDBC 템플릿은 jdbc 라이브러리만 등록하면 추가가 된다. 
    ```properties
    implementation 'org.springframework.boot:spring-boot-starter-jdbc'
    ```

- 테이블 생성  
    JDBC템플릿 학습을 위해 h2 데이터베이스에 item 테이블을 아래와 같이 생성해주자.  
    ```sql
    drop table if exists item CASCADE;
    --기존 item 테이블 및 연관된 데이터 삭제--
    create table item
    (
        id bigint generated by default as identity,
        item_name varchar(10),
        price integer,
        quantity integer,
        primary key (id)
    );
    ```

템플릿을 적용하는 방법은 이전 [스프링 예외 추상화 및 JDBC 반복 해결](../스프링%20DB%201편%20-%20데이터%20접근%20핵심%20원리/예외처리와%20반복%20해결.md)글에서 마지막에 짧게 다루었다.  

## JDBC 템플릿 활용 예제(순서)

- JdbcTemplateRepositoryV1
    ```java
    private final JdbcTemplate jdbcTemplate;

    @Override
    public Item save(Item item) {
        String sql = "insert into item(item_name,price,quantity) values(?,?,?)";
        /*KeyHolder와 connection.prepareStatement(sql, new String[]{"id"})를 사용해서 
        id를 지정해주면 INSERT 쿼리 실행 이후에 데이터베이스에서 생성된 id값 조회 가능*/
        KeyHolder key = new GeneratedKeyHolder();
        //jdbcTemplate.update(sql,item.getItemName(),item.getPrice(),item.getQuantity());
        jdbcTemplate.update(con -> {
            PreparedStatement ps = con.prepareStatement(sql,new String[]{"id"});
            ps.setString(1, item.getItemName());
            ps.setInt(2,item.getPrice());
            ps.setInt(3,item.getQuantity());
            return ps;
        },key);
        long item_id = key.getKey().longValue();
        item.setId(item_id);
        return item;
    }

    @Override
    public void update(Long itemId, ItemUpdateDto updateParam) {
        String sql = "update item set item_name=?, price=?, quantity=? where id=?";
        jdbcTemplate.update(sql, updateParam.getItemName(), updateParam.getPrice(), updateParam.getQuantity(), itemId);
    }

    @Override
    public Optional<Item> findById(Long id) {
        String sql = "select * from item where id = ?";
        try{
            Item item = jdbcTemplate.queryForObject(sql, getItemRowMapper(), id);
            return Optional.of(item);
        } catch (EmptyResultDataAccessException e) {
            return Optional.empty();
        }
    }

    @Override
    public List<Item> findAll(ItemSearchCond cond) {
        String itemName = cond.getItemName();
        Integer maxPrice = cond.getMaxPrice();
        String sql = "select id, item_name, price, quantity from item";
        //동적 쿼리 작성
        if (StringUtils.hasText(itemName) || maxPrice != null) {
            sql += " where";
        }
        boolean andFlag = false; //and or X 
        List<Object> param = new ArrayList<>();
        if (StringUtils.hasText(itemName)) {
            // like concat('%itemName%') << `itemName`이 포함되는 item_name 조회
            sql += " item_name like concat('%',?,'%')";
            param.add(itemName); // param에 itemName 추가 후
            andFlag = true; // Falg = true
        }
        if (maxPrice != null) {
            if (andFlag) { // true일 경우(itemName이 있을경우) and 붙임
                sql += " and";
            }
            sql += " price <= ?"; // maxPrice보다 작은 price값의 item 조회
            param.add(maxPrice);
        }
        log.info("sql={}", sql);
        //query(sql문,RowMapper<T>, 3번째 부터 파라미터로 Object[]로 넘겨도됨);
        return jdbcTemplate.query(sql, getItemRowMapper(), param.toArray());
    }

    private RowMapper<Item> getItemRowMapper() {
        return (rs, rowNum) -> {
            Item getitem = new Item(rs.getString("item_name"), rs.getInt("price"), rs.getInt("quantity"));
            getitem.setId(rs.getLong("id"));
            return getitem;
        };
    }
    ```

### KeyHolder  

KeyHolder와 connection.prepareStatement(sql, new String[]{"id"})를 사용 시  
데이터베이스에서 생성된 'id'컬럼의 값을 KeyHolder로 가져올 수 있다.  
ex) 
```java
 KeyHolder key = new GeneratedKeyHolder();
        //jdbcTemplate.update(sql,item.getItemName(),item.getPrice(),item.getQuantity());
        jdbcTemplate.update(con -> {
            PreparedStatement ps = con.prepareStatement(sql,new String[]{"id","item_name"});
            // ps.set...
        },key)
        long item_id = key.getKeys().longValue();
        String item_name = key.getKeys().get("item_name")
```
이런식으로 데이터베이스에 저장됫던 item이름도 가져올 수 있다.  

### 동적 쿼리

검색한 상품명 또는 최대가격값이 있으면 현재 sql문 뒤에 where을 붙인다.   
```java
 if (StringUtils.hasText(itemName) || maxPrice != null) {
    sql += " where";
}
```

검색한 상품명이 있을때 sql문에 like 조건절 추가
```java
if (StringUtils.hasText(itemName)) {
    // like concat('%itemName%') << `itemName`이 포함되는 item_name 조회
    sql += " item_name like concat('%',?,'%')";
    param.add(itemName); // param에 itemName 추가 후
    andFlag = true; // Falg = true
}
```

검색한 상품명이 있었을 경우 and를 먼저 추가한다.  
최대가격을 입력했고 최대가격보다 작거나 같은 가격 조건 추가  
```java
if (maxPrice != null) {
    if (andFlag) { // true일 경우(itemName이 있을경우) and 붙임
        sql += " and";
    }
    sql += " price <= ?"; // maxPrice보다 작은 price값의 item 조회
    param.add(maxPrice);
}
```

### RowMapper<T>

```java
@FunctionalInterface
public interface RowMapper<T> {
    @Nullable
    T mapRow(ResultSet rs, int rowNum) throws SQLException;
}
```
RowMapper의 mapRow메서드를 이용하여 ResultSet의 각 행을 돌면서 해당 행의 데이터를 객체로 변환한다.  
우리가 while(rs.next()){ ~ } 쓴것에서 `~`해당하는 내부코드만 작성한다고 보면 된다.  

### JdbcTemplate 메서드 간단 정리
\- update() : 데이터 수정 시 사용 (DML select 제외)  
\- excute() : 임의의 SQL 문을 실행  
\- queryForObject() : 하나의 건을 조회시 사용  
\- query() : 다수의 건을 조회시 사용  
등..

[JdbcTemplate API](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html)  

### 스프링 설정 등록

JdbcTemplateRepositoryV1를 사용하는 설정파일을 만들자.  
기존에 메모리에 저장하는 Repository를 썻엇다.  
JdbcTemplate으로 교체해보자.  

- JdbcTemplateV1Config.class

    ```java
    @Configuration
    @RequiredArgsConstructor
    public class JdbcTemplateV1Config {

        private final DataSource dataSource;

        @Bean
        public ItemService itemService(){
            return new ItemServiceV1(itemRepository());
        }
        @Bean
        public ItemRepository itemRepository() {
            //Repository를 V1으로 등록
            return new JdbcTemplateRespositoryV1(dataSource);
        }
    }
    ```

- ItemServiceApplication.class

    @Import(MemoryRepository.class) -> @Import(JdbcTemplateV1Config.class) 변경

- application.properties
    ```s
    spring.datasource.url=jdbc:h2:tcp://localhost/~/test
    spring.datasource.username=sa
    spring.datasource.password=

    #프로필 설정
    spring.profiles.active=local
    #Test데이터 등록을 하기 싫다면 local을 삭제

    #jdbcTemplate 로그 확인
    logging.level.org.springframework.jdbc=debug
    ```

### 실행 결과

- 등록,수정,조회
    ![image](https://github.com/9ony/9ony/assets/97019540/793e346a-2364-4ad4-91e5-230db91dd448)

    상품 등록 및 수정 기능 및 상품조회가 잘되는 것을 볼 수 있다.  
    실제 H2 데이터베이스에 추가되고 저장된 값들이 조회된다.  

- 검색 기능
    (상품 데이터 추가 후 진행)  

    __전체 목록__  
    ![image](https://github.com/9ony/9ony/assets/97019540/e8e6a0cd-4594-478d-8e0a-27aa8fbe15a3)

    __검색 필터 기능__  
    ![image](https://github.com/9ony/9ony/assets/97019540/d85dbb5a-51cc-4c71-b704-776e2ca752bc)


## 이름지정 JDBC템플릿 ( NamedParameterJdbcTemplate )

```java
String sql = "update item set item_name=?, quantity=?, price=? where id=?";
template.update(sql,itemName,quantity,price,itemId);
```

위와 같은 sql문에 바인딩을 한다고 생각해보자.  
이떄 만약 update() 메서드에서 파라미터 순서가 price와 quantity가 아래처럼 바뀌엇다고 가정하면,  
```java
template.update(sql,itemName,price,quantity,itemId);
```
데이터베이스에 quantity가 들어가야할 곳에 price가들어가고 price에는 quantity값이 들어가게 될것이다.  
아니면 특정 수량제한이 있거나 최소가격에 제한을 설정해두어서 오류가 뜨면 다행이지만, 만약 데이터가 들어갈 경우에는 큰일이다.  
데이터베이스에 접속하여 잘못들어간 데이터들을 일일히 다 변경해주거나 되돌리는 등의 복구작업을 해야 한다.  
오류로인해 코드를 고치는것보다 데이터가 잘못 들어가서 데이터베이스를 복구하는게 훨씬 힘들다.  

### NamedParameterJdbcTemplate SQL문 작성법

JdbcTemplate은 위와 같은 문제를 보완하기 위해 `NamedParameterJdbcTemplate`객체가 파라미터를 바인딩 하는 기능을 제공한다

- NamedParameterJdbcTemplate 주입
    
    ```java
    // 변경 전
    private final JdbcTemplate jdbcTemplate;
    // 변경 후
    private final NamedParameterJdbcTemplate template;
    public JdbcTemplateRepositoryV2(DataSource dataSource) {
        this.template = new NamedParameterJdbcTemplate(dataSource);
    }
    ```

- sql문 차이
    기존 save()를 예시  
    ```java
    //기존
    String sql = "insert into item(item_name,price,quantity) values(?,?,?)";
    //변경
    String sql = "insert into item (item_name, price, quantity) " + "values (:itemName, :price, :quantity)";
    ```
    이제 `?`가 아닌 `:파라미터이름`으로 받는다.  
    이후 설명할 NamedParameterJdbcTemplate의 메서드에 key,value구조인 객체를 파라미터로 넘기는데,  
    해당 객체의 key값이 values안에 `:파라미터이름`에 맞으면 해당 객체의 key의 값을 넣어준다.  

### NamedParameterJdbcTemplate 바인딩 파라미터 

NamedParameterJdbcTemplate은 아래와 같이 sql문(String)과 param(Map<String,T>)을 파라미터로 받는다.
이름 지정 바인딩에서 자주 사용하는 파라미터의 종류는 크게 3가지가 있다.  

- param(Map Type) 종류
    - Map<String,Object>
    - MapSqlParameterSource (SqlParameterSource의 구현체)
    - BeanPropertySqlParameterSource (SqlParameterSource의 구현체)

- __Map<String,Object> 예제__  
    ```java
    public Item findById(Long id) {
    String sql = "select id, item_name, price, quantity from item where id = :id ";
    Map<String, Object> param = Map.of("id", id);
    Item item = template.queryForObject(sql, param, itemRowMapper());
    ```

    param에 sql문에 :id에 맞춰 키값을 "id" Value를 메서드파라미터로 들어온 id값을 넣어준다.  

- __MapSqlParameterSource 예제__
    SQL에 좀 더 특화된 기능을 제공하는 Map과 유사한 객체  
    MapSqlParameterSource 는 메서드 체인을 통해 편리한 사용법도 제공  

    ```java
    public void update(Long itemId, ItemUpdateDto updateParam) {
    String sql = "update item " + "set item_name=:itemName, price=:price, quantity=:quantity "
                + "where id=:id";
        SqlParameterSource param = new MapSqlParameterSource()
                .addValue("itemName", updateParam.getItemName())
                .addValue("price", updateParam.getPrice())
                .addValue("quantity", updateParam.getQuantity())
                .addValue("id", itemId); //이 부분이 별도로 필요하다.
        template.update(sql, param);
    }
    ```
    addValue("키 이름",데이터) 추가로 sql Type번호,타입이름도 추가가능하다.  
    참고로 `ItemUpdateDto`은 필드에 id가 없기때문에 해당 SQL문에서는 밑에서 설명할 `BeanPropertySqlParameterSource을 사용하지 못한다`.  
    그래서 `MapSqlParameterSource을 통해 id도 추가`해주는 것이다.

- __BeanPropertySqlParameterSource 예제__  
    ```java
    public Item save(Item item) {
        String sql = "insert into item (item_name, price, quantity) " +
                        "values (:itemName, :price, :quantity)";
        SqlParameterSource param = new BeanPropertySqlParameterSource(item);
        KeyHolder key = new GeneratedKeyHolder();
        template.update(sql, param, key);
        Long item_id = key.getKey().longValue();
        item.setId(item_id);
        return item;
    }
    public class Item {

        private Long id;
        private String itemName;
        private Integer price;
        private Integer quantity;
        //생성자 getter setter 생략
    }
    ```

    BeanPropertySqlParameterSource 생성 시 item객체를 넘겨주고 있다.  
    이때 자바빈 프로퍼티 규약을 통해서 자동으로 파라미터 객체를 생성한다.  
    그리고 KeyHolder를 이용하여 데이터베이스에 저장된 값을 조회하는 부분도 
    param의 key값을 이용하여 들고오기 때문에 따로 String 배열로 줄 필요가 없이 코드가 깔끔해졌다.    

- __BeanPropertyRowMapper 예제__  
    ```java
    private RowMapper<Item> itemRowMapper() {
        return BeanPropertyRowMapper.newInstance(Item.class); //camel 변환 지원
    }

    //기존
    private RowMapper<Item> getItemRowMapper() {
        return (rs, rowNum) -> {
            Item getitem = new Item(
                rs.getString("item_name"),
                rs.getInt("price"), 
                rs.getInt("quantity")
            );
            getitem.setId(rs.getLong("id"));
            return getitem;
        };
    }
    ```

    BeanPropertyRowMapper를 사용하면 ResultSet의 결과를 받아서 자바빈 규약에 맞추어 데이터를 변환한다.  
    근데 여기서 ResultSet으로 넘어오는 item_name은 Item객체에는 itemName인데 이를 카멜표기법으로 자동으로 변환도 해준다.  
    만약 조회시 select name 으로 조회하고 객체 필드명은 itemName이라면 별칭을 사용하자.  
    > select name -> select name as itemName


## SimpleJdbcInsert

INSERT SQL문을 직접 작성하지 않아도 되는 편리한 기능을 제공한다.

- SimpleJdbcInsert 적용 코드
    ```java
    public class JdbcTemplateRepositoryV3 implements ItemRepository {
        private final NamedParameterJdbcTemplate template;
        private final SimpleJdbcInsert jdbcInsert;

        public JdbcTemplateRepositoryV3(DataSource dataSource) {
            this.template = new NamedParameterJdbcTemplate(dataSource);
            this.jdbcInsert = new SimpleJdbcInsert(dataSource)
                    .withTableName("item")
                    .usingGeneratedKeyColumns("id");
                    // .usingColumns("item_name", "price", "quantity");
        }
        @Override
        public Item save(Item item) {
            SqlParameterSource param = new BeanPropertySqlParameterSource(item);
            Number key = jdbcInsert.executeAndReturnKey(param);
            //insert문 실행 및 키반환까지 한다.
            item.setId(key.longValue());
            return item;
        }
        //이외 메서드 생략
    }
    ```
- SimpleJdbcInsert 
    \- withTableName : 데이터를 저장할 `테이블을 지정`  
    \- usingGeneratedKeyColumns : key를 생성하는 `PK컬럼명을 지정`한다.  
    \- usingColumns : INSERT `SQL문에 사용할 컬럼을 지정`한다. (생략 시 모든컬럼)

- save()
    jdbcInsert.executeAndReturnKey(param)을 사용해서 INSERT SQL을 실행  
    생성된 키 값도 매우 편리하게 조회 가능하다.  
    이때 반환되는 키의 컬럼은 usingGeneratedKeyColumns()에서 설정한 컬럼명의 값 반환  



## 정리
JdbcTemplate를 사용하기 위해 jdbc라이브러리만 등록하면 사용할 수 있어서 설정이 간편했고,
JdbcTemplate를 통해 기존 jdbc에서 반복되는 문제등을 해결할 수 있었다.  

- JdbcTemplate : 순서 기반 파라미터 바인딩
    ex) 
    ```java
    String sql = "update item set item_name=?, price=?, quantity=? where id=?";
    jdbcTemplate.update(sql, updateParam.getItemName(), updateParam.getPrice(), updateParam.getQuantity(), itemId);
    ```
- NamedParameterJdbcTemplate : 이름 기반 파라미터 바인딩을 지원
    ex)
    ```java
    String sql = "insert into item (item_name, price, quantity) " + "values (:itemName, :price, :quantity)";
    SqlParameterSource param = new BeanPropertySqlParameterSource(item);
    jdbcTemplate.update(sql,param)
    ```
    파라미터 바인딩 객체 종류 : Map<String,Object> , MapSqlParameterSource , BeanPropertySqlParameterSource

- SimpleJdbcInsert : INSERT SQL문을 편리하게 사용 가능  
    ex)
    ```java
    SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(dataSource)
                    .withTableName("item")
                    .usingGeneratedKeyColumns("id");

    SqlParameterSource param = new BeanPropertySqlParameterSource(item);
    jdbcInsert.executeAndReturnKey(param);
    ```

Jdbc템플릿의 주요 메서드와 간단한 예시
\- update() : 데이터 수정 시 사용 (DML select 제외)  
\- excute() : 임의의 SQL 문을 실행  
\- queryForObject() : 하나의 건을 조회시 사용  
\- query() : 다수의 건을 조회시 사용  
등이 있다..

[스프링 JdbcTemplate 사용 방법 공식 메뉴얼](https://docs.spring.io/spring-framework/reference/data-access/jdbc/core.html#jdbc-JdbcTemplate)

JdbcTemplate을 쓸지 NamedParameterJdbcTemplate쓸지는 상황에 따라 정하면 될것 같다.  
하지만 NamedParameterJdbcTemplate이 바인딩과정에서 좀더 명확하기 때문에 해당 템플릿을 더 권장한다.