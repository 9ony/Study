# 웹 애플리케이션 이해

## 웹서버와 WAS의 차이

### 웹 서버 (Web Server)

- HTTP 기반으로 동작  
- 정적 리소스 제공 및 기타 부가기능  
    정적 리소스 = HTML,CSS,JS,Imaga,mpeg 등..  

- 동적인 컨텐츠 제공을 위한 요청 전달  
    -> 클라이언트의 요청(Request)을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달(응답, Response)함  
- 클라이언트 = 일반적으로 웹 브라우저를 의미  
- 로드밸런싱 , 암호화 처리 , 동적인 처리를 하는 WAS에 부하 방지  

대표적인 웹서버 : NGINX,APACHE 등 

### WAS ( Web Application Server)

- 컨테이너, 웹 컨테이너, 서블릿 컨테이너로도 불림 
- HTTP 기반으로 동작  
- 프로그램 실행 환경과 데이터베이스 접속 기능을 제공  
- 서블릿,JSP 등을 구동하기 위한 컨테이너가 내장  
- 비즈니스 로직을 수행  
- 여러개의 트랜잭션을 관리  

대표적인 WAS : Jetty,Tomcat,WebSphere, Jeus

### Web Server와 WAS를 나누는 이유와 장점
Web Server도 비즈니스 로직을 실행하는 내장 컨테이너를 최근에는 보유하고 있음  
그리고 WAS도 정적처리가 가능함  

__그럼에도 나누는 이유?__

- 비용 처리가 많은 비즈니스 로직을 수행하는 WAS를 Scale-out(수평확장) 할 수 있다.
- 정적인 요소를 처리하는 웹서버는 부담이 적기 때문에 뻗을 일이 WAS보다 적다.
    위 상황에 부가적으로 WAS가 과부화되서 종료된다면 Web Server에서 오류메세지를 클라이언트에게 전송가능  
    그리고 수평확장된 다른 WAS가 대신 처리 가능(효율적인 리소스 관리)  

- 외부에서 중요한 기능을 수행하는 WAS를 직접적으로 알기 힘듬(보안에 용이)  

## 서블릿이란?

동적 페이지를 만들 때 사용되는 자바기반의 웹 애플리케이션 프로그래밍 기술  

- 서블릿 역할
    - 개발자가 HTTP 스펙을 편리하게 사용할 수 있게 해줌(HttpServletRequest,HttpServletResponse 상속받음)  
    - 개발자는 의미있는 비즈니스 로직에 집중  
    - 동적으로 페이지를 제공하기 위해 사용  
    - Thread를 이용하여 동작함    
        > `CGI`는 웹서버와 요청을 받아 처리해줄 로직을 담고 있는 애플리케이션 프로그램 사이의 인터페이스이다.  
        CGI는 매 요청이 들어올 각각의 CGI 구현체를 통해 동작하는데 이때 `요청시마다 프로세스를 생성`하여 동작(서버 부하가 심함)한다.  
        서블릿은 서블릿 컨테이너와 함께 이를 해결하기 위해 등장하였다.  
        CGI가 매 요청마다 프로세스를 생성하는 것을 서블릿 컨테이너에 위임하고 서블릿 컨테이너가 멀티스레딩을 지원하여 `서블릿이 쓰레드단위로 동작`하는 것이다.

- 서블릿 동작 과정
    
    ![Servlet 동작 과정 이미지](https://t1.daumcdn.net/cfile/tistory/993A7F335A04179D20?original)  

    1. 클라이언트가 HTTP 요청  
    2. 서블릿 컨테이너가 클라이언트가 전송한 요청받으면 HttpServletRequest, HttpServletResponse 객체를 생성  
    3. 해당 요청URL을 web.xml을 기반으로 분석하여 어떤 서블릿 탐색  
    4. 해당 비지니스 로직을 실행하고 doGet() or doPost() 호출  
    5. 동적 페이지를 생성한 후 HttpServletResponse객체에 응답  
    6. HttpServletRequest, HttpServletResponse 객체를 소멸  

    [이미지 및 동작과정 출처](https://mangkyu.tistory.com/14)  

## 서블릿 컨테이너란?

서블릿을 관리하고 해당 서블릿이 정의한 역할을 수행하는 것이 서블릿 컨테이너 입니다.  
대표적인 서블릿 컨테이너는 Tomcat,Jetty,JBoss 등이 있습니다.  
스프링 부트는 Tomcat을 내장하고 있음.  

- 서블릿 컨테이너의 역할  
    - 웹서버와의 통신 지원  
        소켓생성 , 요청 및 응답처리를 API로 제공 (개발자가 편리)  
    - 서블릿 생명주기(Life Cycle) 관리  
        서블릿 클래스를 로딩하여 인스턴스화   
        요청에 따른 적절한 서블릿 메소드 실행  
        서블릿이 제 역할을 다하면 Garbage Collection(가비지 컬렉션)을 진행(메모리 관리)  
    - 멀티쓰레드 지원 및 자원 관리  
        HTTP 요청 시 마다 쓰레드를 생성하여 실행하는데,  
        이때 쓰레드를 미리 생성(쓰레드 풀) 해놓아서 사용하거나 요청 시 마다 생성 할 수도 있다.  
        쓰레드풀 장점 : 쓰레드 생성 비용 절감, 응답시간 단축, 자원 관리  
    - 보안관리
        서블릿 컨테이너를 사용하면 보안 관련된 내용은 서블릿에 구현하지 않고
        서블릿 컨테이너 설정 파일(web.xml)에 기술한다.  
        보안에 대해 수정할 일이 생겨도 자바 소스 코드를 수정하여 다시 컴파일하지 않아도 됨  

❗❗ 주의할점 
멀티 쓰레드 환경이므로 싱글톤(스프링 빈, 서블릿 등) 객체 사용시 주의해야함!  
    [위 주의 상황에 참고 할만한 자료](https://velog.io/@jeonye/%EA%B0%9C%EB%85%90-%EC%8A%A4%ED%83%9D%EA%B3%BC-%ED%9E%99-%EB%A9%94%EB%AA%A8%EB%A6%AC)

## HTTP API

HTTP API는 HTTP를 사용해서 서로 정해둔 스펙으로 데이터를 주고 받으며 통신하는 것이다.  

__HTTP API란?__  
- 정적 리소스(HTML,css 등)가 아니라 데이터를 전달  
- 주로 JSON 형식 사용  
- 다양한 시스템에서 호출 가능  
- 정적 리소스를 제외한 많은 곳에서 사용함

__REST API란?__  
이와 비슷한 개념으로 REST API라는 것이 있는데, 
해당 개념은 4가지 원칙이 존재한다.  
- 리소스의 식별  
- 메세지를 통한 리소스 조작( 리소스에 대해 어떤 조작을 하는지 명시 )  
- 자기 서술적 메세지( 메세지가 어떤걸 의미하는지 명확해야함 )  
- HATEOAS ( 현재 상태에서 어떤 페이지로 이동가능한지 보여야함 )  

[REST API 출처]( https://ko.wikipedia.org/wiki/REST )

### HTTP API를 통한 다양한 시스템 연동  
- JSON 형태로 통신  
- 다양한 클라이언트(웹,앱 등)에서 HTTP API 호출  
- 서버와 서버끼리 통신  

![image](https://github.com/9ony/9ony/assets/97019540/fd23c252-7eeb-42f1-8ec2-957bccbdd6c2)

위 그림과 같이 WAS에서 데이터만 전송하고 웹 브라우저나 앱 같은 경우에 화면 구성은 따로 데이터만 가지고 동적인 화면을 구성할 수 있다.

## 웹 렌더링의 방식

### 서버 사이드 렌더링(SSR)

클라이언트가 서버에게 요청하면 해당 요청한 데이터와 화면의 최종적인 View를 서버에서 렌더링해서 제공하는 것이다.  

![image](https://github.com/9ony/9ony/assets/97019540/495b6182-c638-4fa3-99a6-e6ded1d486a3)

1. 클라이언트가 서버에 접속 후 /order.html을 요청한다.  
2. 서버는 사용자에 요청한 order.html 렌더링하여 클라이언트에 전송한다.  
3. 사용자가 요청한 HTML을 확인한다.

- 특징
    - 첫 페이지 로딩 속도가 빠르다  
    - 컨텐츠가 HTML에 담겨있기 때문에 검색엔진 최적화에 유리  
    - 서버에서 뷰를 만들어서 처리하니 부하가 CSR보다 높음
    - 페이지 전환 시 블링킹 이슈(화면 깜빡임)

### 클라이언트 사이드 렌더링(CSR)

클라이언트(브라우저)에서 웹 페이지를 렌더링하는 것이다. 모든 로직, 데이터 가져오기, 템플릿, 라우팅은 서버가 아닌 모두 클리이언트에서 처리하는 것이다.  

> Angular, React, Vue 와 같은 유명한 프레임워크들이 사용하고 있는 방식

![image](https://github.com/9ony/9ony/assets/97019540/fbec5205-00e4-4fd9-aaf5-21aa1ae4e728)

1. 클라이언트가 서버에 접속 후 서버는 비어있는 html과 js링크만을 넘겨줌  
2. 클라이언트는 자바스크립트 링크로 자바스크립트 번들을 받는다.  
3. 클라이언트가 해당 자바스크립트 번들을 빌드한 후 화면 구성에 필요한 데이터를 서버 요청한다.  
4. 클라이언트는 받아온 데이터로 렌더링하고 사용자가 확인한다.  

- 특징  
    - 첫 페이지 로딩 속도가 느리다  
    - 서버에서 전송한 바디가 비어있어서 검색엔진 최적화가 힘들다  
        `구글`은 검색엔진은 js도 해석가능 하다고 하다.  
        다른 검색엔진에도 노출하려면 pre-rendering을 참고해보자  
    - 클라이언트에서 렌더링 하기 때문에 서버에 부담이 적다  
    - 블링킹 이슈가 없음  
    - 웹 환경을 마치 앱 처럼 필요한 부분 변경가능  

참고 : Jamstack이란 방법도 있고 CSR과 SSR을 동시에 적절히 사용하는 유니버셜 렌더링 방식도 존재함  

## 자바 웹 기술 역사

### 과거 기술
- 서블릿 - 1997  
    HTML 생성이 어려움  
- JSP(뷰 템플릿) - 1999
    HTML 코드에 JAVA 코드를 넣어 동적웹페이지를 생성하는 웹어플리케이션 도구  
    HTML 생성은 편리하지만, 비즈니스 로직까지 너무 많은 역할 담당  
- 서블릿, JSP 조합 MVC 패턴 사용  
    모델, 뷰 컨트롤러로 역할을 나누어 개발  
- MVC 프레임워크 춘추 전국 시대 - 2000년 초 ~ 2010년 초  
    MVC 패턴 자동화, 복잡한 웹 기술을 편리하게 사용할 수 있는 다양한 기능 지원  
    스트럿츠, 웹워크, 스프링 MVC(과거 버전)  

### 현재 사용 기술
- 애노테이션 기반의 스프링 MVC 등장
    ex) @Controller,@Service,@Mapper 등..
    이로인해 대부분 스프링을 쓰게됨  
- 스프링 부트의 등장
    스프링 부트는 서버를 내장  
    과거에는 서버에 WAS를 직접 설치하고, 소스는 War 파일을 만들어서 설치한 WAS에 배포  
    스프링 부트는 빌드 결과(Jar)에 WAS 서버 포함 -> 빌드 배포 단순화  

### 자바 뷰 템플릿 종류
- JSP
    속도 느림, 기능 부족  
- 프리마커(Freemarker), Velocity(벨로시티)
    속도 문제 해결, 다양한 기능  
    발전 속도가 느리다함  
- 타임리프(Thymeleaf)
    내추럴 템플릿: HTML의 모양을 유지하면서 뷰 템플릿 적용 가능(깔끔함)  
    스프링 MVC와 강력한 기능 통합 (사용하는 굉장히 큰 이유)  
    단, 성능은 프리마커, 벨로시티가 더 빠름  